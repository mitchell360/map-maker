<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>URL Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet-dvf@0.2.5/dist/css/dvf.css">
  <style>
    html,body,#map{height:100%;margin:0;padding:0}
    .leaflet-popup-content{font:22px/1.5 "Segoe UI",Roboto,Helvetica,Arial,sans-serif;color:#1f2937;letter-spacing:0;margin:0;min-width:400px}
    .leaflet-popup-content-wrapper{border-radius:8px;padding:32px 36px;background:#ffffff;border:3px solid #1f2937;box-shadow:0 10px 40px rgba(0,0,0,.3);max-width:600px}
    .leaflet-popup-tip{background:#ffffff;border:3px solid #1f2937;box-shadow:0 8px 20px rgba(0,0,0,.2)}
    .popup-line{display:block;white-space:pre-wrap;margin-bottom:14px;line-height:1.5}
    .popup-line:first-child{font-weight:700;font-size:52px;color:#0369a1;letter-spacing:-.01em;margin-bottom:12px;line-height:1.1}
    .popup-line:nth-child(2),.popup-line:nth-child(3){color:#6b7280;font-size:20px;margin-bottom:8px}
    .popup-line:nth-child(n+4){color:#1f2937;font-size:22px;margin-top:20px;margin-bottom:10px}
    .popup-line:last-child{margin-bottom:0}
    .marker-label{background:#0369a1;color:#ffffff;border:none;box-shadow:0 2px 8px rgba(0,0,0,.3);font-weight:700;font-size:16px;padding:6px 12px;border-radius:4px}
    .marker-label::before{border-top-color:#0369a1!important}
    .marker-label-reference{background:#dc2626;color:#ffffff;border:none;box-shadow:0 2px 8px rgba(0,0,0,.3);font-weight:700;font-size:16px;padding:6px 12px;border-radius:4px}
    .marker-label-reference::before{border-top-color:#dc2626!important}
    .distance-info{position:absolute;z-index:1000;bottom:12px;left:50%;transform:translateX(-50%);background:#fff;padding:10px 16px;border-radius:6px;font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;box-shadow:0 2px 12px rgba(0,0,0,.2);border:2px solid #0369a1}
    .callout-label-blue{background:#0369a1;color:#ffffff;padding:8px 14px;border-radius:4px;font-weight:700;font-size:15px;white-space:nowrap;box-shadow:0 2px 10px rgba(0,0,0,.25);border:2px solid #ffffff}
    .callout-label-red{background:#dc2626;color:#ffffff;padding:8px 14px;border-radius:4px;font-weight:700;font-size:15px;white-space:nowrap;box-shadow:0 2px 10px rgba(0,0,0,.25);border:2px solid #ffffff}
  </style>
</head>
<body>
<div id="map"></div>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://cdn.jsdelivr.net/npm/leaflet-dvf@0.2.5/dist/leaflet-dvf.min.js"></script>
<script>
function qs(name){const u=new URL(location.href);return u.searchParams.get(name);}
async function geocode(q){
  const url='https://nominatim.openstreetmap.org/search?format=json&limit=1&q='+encodeURIComponent(q);
  const r=await fetch(url,{headers:{'Accept-Language':'en','User-Agent':'URL-Map/1.0'}});
  if(!r.ok)return null;
  const j=await r.json();
  if(j&&j.length)return{lat:parseFloat(j[0].lat),lon:parseFloat(j[0].lon),display:j[0].display_name};
  return null;
}
async function getWalkingRoute(start,end){
  const coords=`${start.lon},${start.lat};${end.lon},${end.lat}`;
  const url=`https://routing.openstreetmap.de/routed-foot/route/v1/foot/${coords}?overview=full&geometries=geojson`;
  try{
    const r=await fetch(url);
    const data=await r.json();
    if(data.code==='Ok'&&data.routes&&data.routes.length>0){
      return{
        distance:data.routes[0].distance,
        duration:data.routes[0].duration,
        geometry:data.routes[0].geometry
      };
    }
  }catch(e){console.error('Route error:',e);}
  return null;
}
function getDistance(lat1,lon1,lat2,lon2){
  const R=6371;
  const dLat=(lat2-lat1)*Math.PI/180;
  const dLon=(lon2-lon1)*Math.PI/180;
  const a=Math.sin(dLat/2)*Math.sin(dLat/2)+Math.cos(lat1*Math.PI/180)*Math.cos(lat2*Math.PI/180)*Math.sin(dLon/2)*Math.sin(dLon/2);
  const c=2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a));
  return R*c;
}
function assignDirection(locations,index){
  const loc=locations[index];
  const proximityThreshold=200;
  const nearby=[];
  for(let i=0;i<locations.length;i++){
    if(i===index)continue;
    const dist=getDistance(loc.lat,loc.lon,locations[i].lat,locations[i].lon);
    if(dist<proximityThreshold){
      nearby.push({index:i,dist:dist});
    }
  }
  if(nearby.length===0)return 'ne';
  nearby.sort((a,b)=>a.dist-b.dist);
  const angles=nearby.map(n=>{
    const dx=locations[n.index].lon-loc.lon;
    const dy=locations[n.index].lat-loc.lat;
    return Math.atan2(dy,dx)*180/Math.PI;
  });
  const directions=['ne','se','sw','nw'];
  const dirAngles=[45,135,-135,-45];
  let bestDir='ne';
  let maxMinDist=0;
  for(let d=0;d<directions.length;d++){
    let minDist=360;
    for(let a of angles){
      let diff=Math.abs(a-dirAngles[d]);
      if(diff>180)diff=360-diff;
      minDist=Math.min(minDist,diff);
    }
    if(minDist>maxMinDist){
      maxMinDist=minDist;
      bestDir=directions[d];
    }
  }
  return bestDir;
}
(async function(){
  const map=L.map('map',{zoomControl:true}).setView([20,0],2);
  const dare=L.tileLayer('https://dh.gu.se/tiles/imperium/{z}/{x}/{y}.png',{minZoom:4,maxZoom:11,attribution:'© <a href="https://dh.gu.se/dare/">Digital Atlas of the Roman Empire</a>'}).addTo(map);
  const positron=L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png',{maxZoom:19,attribution:'© OpenStreetMap © CartoDB'});
  const osm=L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:19,attribution:'© OpenStreetMap'});
  const baseLayers={'Ancient World':dare,'Modern (Clean)':positron,'Modern (Detailed)':osm};
  
  // Custom marker icons
  const blueIcon=L.icon({iconUrl:'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-blue.png',shadowUrl:'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',iconSize:[25,41],iconAnchor:[12,41],popupAnchor:[1,-34],shadowSize:[41,41]});
  const redIcon=L.icon({iconUrl:'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',shadowUrl:'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',iconSize:[25,41],iconAnchor:[12,41],popupAnchor:[1,-34],shadowSize:[41,41]});
  
  // Create overlay layers
  const countryBorders=L.layerGroup();
  const walkingPaths=L.layerGroup();
  const travelTimeLayer=L.layerGroup();
  
  // Add invisible placeholders so layers show in control
  walkingPaths.addLayer(L.circle([0,0],{radius:1,opacity:0}));
  travelTimeLayer.addLayer(L.circle([0,0],{radius:1,opacity:0}));
  
  // Load country borders
  fetch('https://d2ad6b4ur7yvpq.cloudfront.net/naturalearth-3.3.0/ne_110m_admin_0_countries.geojson')
    .then(r=>r.json())
    .then(data=>{
      L.geoJSON(data,{
        style:{
          color:'#1f2937',
          weight:2.5,
          opacity:0.8,
          fillOpacity:0
        }
      }).addTo(countryBorders);
    })
    .catch(e=>console.error('Border load error:',e));
  
  // Overlays are OFF by default but available in layer control
  const overlays={
    'Country Borders':countryBorders,
    'Walking Paths':walkingPaths,
    'Travel Time':travelTimeLayer
  };
  L.control.layers(baseLayers,overlays,{collapsed:true}).addTo(map);

  const defaultChronoPoints='Antioch,Turkey|Philippi,Greece|Ephesus,Turkey|Rome,Italy';
  const defaultChronoLabels='Antioch%0A47-48 AD: Antioch, Syria%0A2025 AD: Antakya, Turkey%0A%0AAntioch served as the primary mission base for Paul\'s ministry to the Gentiles and was where believers were first called Christians|Philippi%0A49-50 AD: Philippi, Macedonia%0A2025 AD: Filippoi, Greece%0A%0APhilippi was the first European city where Paul established a Christian congregation during his second missionary journey|Ephesus%0A52-54 AD: Ephesus, Asia Minor%0A2025 AD: Selçuk, Turkey%0A%0APaul ministered in Ephesus for approximately three years during his third missionary journey|Rome%0A62 AD: Rome, Capitol of the Roman Empire%0A2025 AD: Rome, Italy%0A%0APaul was held under house arrest in Rome from approximately AD 60 to 62';
  const defaultRefPoints='Jerusalem,Israel';
  const defaultRefLabels='Jerusalem%0A33 AD: Jerusalem, Judea%0A2025 AD: Jerusalem, Israel%0A%0AThe Church\'s birthplace and site of Pentecost';
  
  // Chronological locations (blue markers, connected with paths)
  const chronoPoints=(qs('chrono')||defaultChronoPoints).split('|').filter(Boolean);
  const chronoLabels=(qs('chronoLabels')||defaultChronoLabels).split('|');
  
  // Reference locations (red markers, no paths)
  const refPoints=(qs('reference')||defaultRefPoints).split('|').filter(Boolean);
  const refLabels=(qs('referenceLabels')||defaultRefLabels).split('|');

  const allMarkers=[];
  const chronoCoords=[];
  const chronoNames=[];
  const chronoData=[];
  
  // First pass: collect all chronological location data
  for(let i=0;i<chronoPoints.length;i++){
    const q=chronoPoints[i].trim();
    if(!q)continue;
    let coord=null;
    const m=q.match(/^(.*)@(-?\d+(?:\.\d+)?),(-?\d+(?:\.\d+)?)$/);
    if(m){coord={lat:parseFloat(m[2]),lon:parseFloat(m[3])};}
    else{coord=await geocode(q);}
    if(!coord)continue;
    chronoCoords.push({lat:coord.lat,lon:coord.lon});
    const labelEncoded=chronoLabels[i]||q;
    const label=labelEncoded.replace(/%0A/gi,'\n');
    const lines=label.split('\n');
    const locationName=lines[0]||q;
    chronoNames.push(locationName);
    chronoData.push({lat:coord.lat,lon:coord.lon,name:locationName,label:label,lines:lines});
  }
  
  // Second pass: create callout markers with intelligent directions
  for(let i=0;i<chronoData.length;i++){
    const d=chronoData[i];
    const dir=assignDirection(chronoData,i);
    const html=d.lines.map(l=>'<span class="popup-line">'+l+'</span>').join('');
    const mk=L.marker([d.lat,d.lon],{icon:blueIcon})
      .addTo(map)
      .bindPopup(html,{autoClose:true,closeOnClick:false});
    allMarkers.push(mk);
    const callout=new L.Callout(new L.LatLng(d.lat,d.lon),{
      arrow:false,
      direction:dir,
      lineStyle:'arc',
      weight:2,
      color:'#0369a1',
      fillColor:'#0369a1',
      fillOpacity:0.9,
      size:new L.Point(100,30),
      icon:new L.DivIcon({html:d.name,className:'callout-label-blue'})
    });
    map.addLayer(callout);
  }
  
  // Process reference locations (red markers)
  const refData=[];
  for(let i=0;i<refPoints.length;i++){
    const q=refPoints[i].trim();
    if(!q)continue;
    let coord=null;
    const m=q.match(/^(.*)@(-?\d+(?:\.\d+)?),(-?\d+(?:\.\d+)?)$/);
    if(m){coord={lat:parseFloat(m[2]),lon:parseFloat(m[3])};}
    else{coord=await geocode(q);}
    if(!coord)continue;
    const labelEncoded=refLabels[i]||q;
    const label=labelEncoded.replace(/%0A/gi,'\n');
    const lines=label.split('\n');
    const locationName=lines[0]||q;
    refData.push({lat:coord.lat,lon:coord.lon,name:locationName,label:label,lines:lines});
  }
  
  // Combine all locations for direction calculation
  const allLocs=[...chronoData,...refData];
  
  // Create reference callout markers
  for(let i=0;i<refData.length;i++){
    const d=refData[i];
    const dir=assignDirection(allLocs,chronoData.length+i);
    const html=d.lines.map(l=>'<span class="popup-line">'+l+'</span>').join('');
    const mk=L.marker([d.lat,d.lon],{icon:redIcon})
      .addTo(map)
      .bindPopup(html,{autoClose:true,closeOnClick:false});
    allMarkers.push(mk);
    const callout=new L.Callout(new L.LatLng(d.lat,d.lon),{
      arrow:false,
      direction:dir,
      lineStyle:'arc',
      weight:2,
      color:'#dc2626',
      fillColor:'#dc2626',
      fillOpacity:0.9,
      size:new L.Point(100,30),
      icon:new L.DivIcon({html:d.name,className:'callout-label-red'})
    });
    map.addLayer(callout);
  }
  
  // Draw walking paths between consecutive chronological locations only
  let totalDistance=0;
  const legDistances=[];
  for(let i=0;i<chronoCoords.length-1;i++){
    const route=await getWalkingRoute(chronoCoords[i],chronoCoords[i+1]);
    if(route&&route.geometry){
      const latlngs=route.geometry.coordinates.map(c=>[c[1],c[0]]);
      L.polyline(latlngs,{color:'#0369a1',weight:3,opacity:0.7}).addTo(walkingPaths);
      totalDistance+=route.distance;
      legDistances.push(route.distance);
    }else{
      legDistances.push(0);
    }
  }
  
  if(allMarkers.length){
    const g=new L.featureGroup(allMarkers);
    map.fitBounds(g.getBounds().pad(0.18));
    
    // Create travel time display
    if(totalDistance>0){
      const formatTime=(distanceMeters)=>{
        const distKm=distanceMeters/1000;
        const walkingDist=distKm*0.6;
        const boatDist=distKm*0.4;
        const walkingDays=walkingDist/25;
        const boatDays=boatDist/100;
        const totalDays=Math.ceil(walkingDays+boatDays);
        const weeks=Math.floor(totalDays/7);
        const days=totalDays%7;
        let timeStr='';
        if(weeks>0)timeStr+=`${weeks} week${weeks>1?'s':''} `;
        if(days>0||weeks===0)timeStr+=`${days} day${days!==1?'s':''}`;
        return {timeStr:timeStr.trim(),distKm:distKm.toFixed(0),totalDays};
      };
      
      // Build legs display
      let legsHtml='';
      for(let i=0;i<legDistances.length;i++){
        if(legDistances[i]>0){
          const legTime=formatTime(legDistances[i]);
          legsHtml+=`<div style="font-size:13px;color:#374151;margin-top:2px;">${chronoNames[i]} → ${chronoNames[i+1]}: <span style="color:#6b7280;">${legTime.timeStr} (${legTime.distKm} km)</span></div>`;
        }
      }
      
      const totalTime=formatTime(totalDistance);
      
      // Create travel time display element (hidden by default)
      const travelTimeDiv=document.createElement('div');
      travelTimeDiv.className='distance-info';
      travelTimeDiv.style.display='none';
      travelTimeDiv.innerHTML=`<strong>Estimated Travel Time:</strong> ${totalTime.timeStr} <span style="font-size:12px;color:#6b7280">(${totalTime.distKm} km via walking & boat)</span><div style="margin-top:8px;">${legsHtml}</div>`;
      document.body.appendChild(travelTimeDiv);
      
      // Show/hide travel time display based on layer toggle
      map.on('overlayadd',function(e){
        if(e.name==='Travel Time')travelTimeDiv.style.display='block';
      });
      map.on('overlayremove',function(e){
        if(e.name==='Travel Time')travelTimeDiv.style.display='none';
      });
    }
  }else{map.setView([37.8,20],5);}
})();
</script>
</body>
</html>
