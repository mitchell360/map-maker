<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>URL Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="">
  <style>
    html,body,#map{height:100%;margin:0;padding:0}
    #map{position:relative;z-index:1}
    
    /* Content styling for drawer - elegant serif fonts matching old popups */
    .drawer-content{font-family:Georgia,Cambria,"Times New Roman",serif}
    .popup-line{display:block;white-space:pre-wrap;margin-bottom:14px;line-height:1.6}
    .popup-line:first-child{font-family:Georgia,Cambria,"Times New Roman",serif;font-weight:700;font-size:32px;color:#0b5394;letter-spacing:0;margin-bottom:16px;line-height:1.2}
    .popup-line:nth-child(2),.popup-line:nth-child(3){color:#5f6368;font-size:15px;margin-bottom:10px;line-height:1.5}
    .popup-line:nth-child(n+4){color:#202124;font-size:16px;margin-top:18px;margin-bottom:12px;line-height:1.6}
    .popup-line:last-child{margin-bottom:0}
    
    /* Unified drawer - works on all devices */
    .drawer-backdrop{position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.5);z-index:2000;display:none;opacity:0;transition:opacity 0.3s ease;pointer-events:none}
    .drawer-backdrop.active{display:block;opacity:1;pointer-events:auto}
    .drawer{position:fixed;background:#fff;box-shadow:0 -4px 20px rgba(0,0,0,0.3);z-index:2001;transform:translateY(100%);transition:transform 0.3s cubic-bezier(0.4,0,0.2,1);display:flex;flex-direction:column;pointer-events:none}
    .drawer.active{transform:translateY(0);pointer-events:auto}
    .drawer-handle{width:40px;height:4px;background:#cbd5e1;border-radius:2px;margin:12px auto 8px;cursor:grab;flex-shrink:0}
    .drawer-content{overflow-y:auto;padding:0 20px 20px;flex:1}
    
    /* Mobile: bottom drawer */
    @media (max-width: 768px) {
      .drawer{bottom:0;left:0;right:0;border-radius:20px 20px 0 0;max-height:70vh}
    }
    
    /* Desktop: centered modal */
    @media (min-width: 769px) {
      .drawer{top:50%;left:50%;right:auto;bottom:auto;transform:translate(-50%,-50%) scale(0.9);border-radius:12px;max-width:600px;width:90%;max-height:80vh;opacity:0;visibility:hidden}
      .drawer.active{transform:translate(-50%,-50%) scale(1);opacity:1;visibility:visible}
      .drawer-handle{display:none}
      .popup-line:first-child{font-size:48px}
      .popup-line:nth-child(2),.popup-line:nth-child(3){font-size:17px}
      .popup-line:nth-child(n+4){font-size:18px}
    }
    
    /* Travel time display - responsive */
    .distance-info{position:absolute;z-index:1500;background:#fff;padding:10px 16px;border-radius:6px;font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;box-shadow:0 2px 12px rgba(0,0,0,.2);border:2px solid #0369a1}
    .distance-info-header{display:flex;justify-content:space-between;align-items:center;gap:8px}
    .distance-info-toggle{background:none;border:none;color:#0369a1;font-size:18px;cursor:pointer;padding:0;line-height:1;display:none}
    .distance-info-details{margin-top:8px}
    
    /* Desktop positioning */
    @media (min-width: 769px) {
      .distance-info{bottom:12px;left:50%;transform:translateX(-50%);max-width:600px}
    }
    
    /* Mobile positioning and collapsible */
    @media (max-width: 768px) {
      .distance-info{bottom:12px;left:12px;right:12px;max-width:none}
      .distance-info-toggle{display:inline-block}
      .distance-info-details{display:none}
      .distance-info-details.expanded{display:block}
      .distance-info-details > div{font-size:12px;line-height:1.5}
    }
    
    /* Instructions link - responsive */
    /* Instructions button - always shows as ? in upper right on all devices */
    .instructions-link{position:absolute;top:90px;left:10px;z-index:1500;background:#fff;border-radius:50%;box-shadow:0 2px 12px rgba(0,0,0,.2);border:2px solid #0369a1;padding:0;width:36px;height:36px;display:flex;align-items:center;justify-content:center}
    .instructions-link a{color:#0369a1;text-decoration:none;font-weight:700;font-size:20px;display:flex;width:100%;height:100%;align-items:center;justify-content:center}
    .instructions-link a:hover{background:#f0f9ff;border-radius:50%}
    
    /* Tooltip styles - high z-index to appear in front of pins */
    .leaflet-tooltip.marker-label{
      background:#0369a1!important;
      color:#ffffff!important;
      border:none!important;
      box-shadow:0 2px 8px rgba(0,0,0,.3)!important;
      font-weight:700!important;
      font-size:14px!important;
      padding:4px 8px!important;
      border-radius:4px!important;
      z-index:1000!important;
    }
    .leaflet-tooltip.marker-label::before{
      border-top-color:#0369a1!important;
    }
    .leaflet-tooltip.marker-label-reference{
      background:#dc2626!important;
      color:#ffffff!important;
      border:none!important;
      box-shadow:0 2px 8px rgba(0,0,0,.3)!important;
      font-weight:700!important;
      font-size:14px!important;
      padding:4px 8px!important;
      border-radius:4px!important;
      z-index:1000!important;
    }
    .leaflet-tooltip.marker-label-reference::before{
      border-top-color:#dc2626!important;
    }
    
    /* Ensure tooltip pane is above markers */
    .leaflet-tooltip-pane{z-index:700!important}
    
    /* Numbered arrow markers for travel direction */
    .arrow-marker{
      background:transparent!important;
      border:none!important;
      box-shadow:none!important;
    }
    .arrow-marker div{
      font-family:system-ui,-apple-system,sans-serif;
    }
    
    /* Map title */
    .map-title{position:absolute;top:12px;left:50%;transform:translateX(-50%);z-index:3100;background:rgba(255,255,255,0.95);padding:12px 24px;border-radius:8px;box-shadow:0 2px 12px rgba(0,0,0,.2);font-family:Georgia,Cambria,"Times New Roman",serif;font-size:24px;font-weight:700;color:#0b5394;text-align:center;max-width:calc(100% - 100px);pointer-events:none}
    @media (max-width: 768px) {
      .map-title{font-size:18px;padding:8px 16px;top:8px;max-width:calc(100% - 80px)}
    }
    
    /* Loading overlay */
    .loading-overlay{position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(255,255,255,0.95);z-index:3000;display:flex;flex-direction:column;align-items:center;justify-content:center;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
    .loading-spinner{width:48px;height:48px;border:4px solid #e5e7eb;border-top-color:#0369a1;border-radius:50%;animation:spin 0.8s linear infinite;margin-bottom:20px}
    @keyframes spin{to{transform:rotate(360deg)}}
    .loading-text{font-size:18px;color:#374151;font-weight:500;margin-bottom:8px}
    .loading-detail{font-size:14px;color:#6b7280}
    
    /* Transport mode selector */
    /* Transport selector - inline in travel time box */
    .transport-inline{display:flex;flex-wrap:wrap;gap:4px;margin-top:8px;padding-top:8px;border-top:1px solid #e5e7eb}
    .transport-inline-title{width:100%;font-size:11px;color:#6b7280;margin-bottom:2px}
    .transport-btn{padding:4px 8px;font-size:11px;border:1px solid #d1d5db;border-radius:4px;background:#fff;cursor:pointer;transition:all 0.15s;white-space:nowrap}
    .transport-btn:hover{border-color:#0369a1;background:#f0f9ff}
    .transport-btn.active{background:#0369a1;color:#fff;border-color:#0369a1}
    .transport-btn .speed{font-size:10px;opacity:0.8}
    
    /* Route mode selector (Land Only / Use Water) */
    .route-mode-inline{display:flex;flex-wrap:wrap;gap:4px;margin-top:8px;padding-top:8px;border-top:1px solid #e5e7eb}
    .route-mode-inline-title{width:100%;font-size:11px;color:#6b7280;margin-bottom:2px}
    .route-btn{padding:4px 10px;font-size:11px;border:1px solid #d1d5db;border-radius:4px;background:#fff;cursor:pointer;transition:all 0.15s;white-space:nowrap}
    .route-btn:hover{border-color:#0891b2;background:#ecfeff}
    .route-btn.active{background:#0891b2;color:#fff;border-color:#0891b2}
    .route-btn .icon{margin-right:4px}
    .water-breakdown{margin-top:6px;padding:6px 8px;background:#f0fdfa;border-radius:4px;font-size:11px;color:#0f766e}
    
    /* Custom layer control panel */
    .layer-panel{position:absolute;top:10px;right:10px;z-index:1500;background:#fff;border-radius:8px;box-shadow:0 2px 12px rgba(0,0,0,.2);font:13px/1.4 system-ui,-apple-system,sans-serif;max-height:calc(100vh - 100px);overflow-y:auto;min-width:220px}
    .layer-panel-header{display:flex;align-items:center;justify-content:space-between;padding:10px 12px;border-bottom:1px solid #e5e7eb;cursor:pointer;user-select:none}
    .layer-panel-header h3{margin:0;font-size:14px;font-weight:600;color:#374151}
    .layer-panel-toggle{font-size:12px;color:#6b7280;transition:transform 0.2s}
    .layer-panel.collapsed .layer-panel-toggle{transform:rotate(-90deg)}
    .layer-panel.collapsed .layer-panel-content{display:none}
    .layer-panel-content{padding:8px 0}
    .layer-section{border-bottom:1px solid #f3f4f6}
    .layer-section:last-child{border-bottom:none}
    .layer-section-header{display:flex;align-items:center;padding:8px 12px;cursor:pointer;user-select:none;background:#f9fafb;font-weight:500;font-size:12px;color:#4b5563}
    .layer-section-header:hover{background:#f3f4f6}
    .layer-section-icon{margin-right:6px;font-size:14px}
    .layer-section-arrow{margin-left:auto;font-size:10px;color:#9ca3af;transition:transform 0.2s}
    .layer-section.collapsed .layer-section-arrow{transform:rotate(-90deg)}
    .layer-section.collapsed .layer-section-items{display:none}
    .layer-section-items{padding:4px 0}
    .layer-item{display:flex;align-items:center;padding:6px 12px 6px 24px;cursor:pointer}
    .layer-item:hover{background:#f9fafb}
    .layer-item input{margin:0 8px 0 0;cursor:pointer}
    .layer-item label{cursor:pointer;flex:1;font-size:12px;color:#374151}
    .layer-item-sub{font-size:10px;color:#9ca3af;margin-left:4px}
    .base-map-item{padding:6px 12px 6px 16px}
    .base-map-item input[type="radio"]{margin:0 8px 0 0}
    .layer-dropdown{margin-left:auto;padding:2px 6px;font-size:10px;border:1px solid #d1d5db;border-radius:4px;background:#fff;cursor:pointer}
    @media (max-width: 768px) {
      .layer-panel{top:auto;bottom:80px;right:10px;left:10px;max-height:50vh;min-width:auto}
    }
  </style>
</head>
<body>
<!-- Loading overlay -->
<div class="loading-overlay" id="loadingOverlay">
  <div class="loading-spinner"></div>
  <div class="loading-text" id="loadingText">Loading map...</div>
  <div class="loading-detail" id="loadingDetail"></div>
</div>

<div id="map"></div>

<!-- Mobile drawer -->
<div class="drawer-backdrop" id="drawerBackdrop"></div>
<div class="drawer" id="drawer">
  <div class="drawer-handle" id="drawerHandle"></div>
  <div class="drawer-content" id="drawerContent"></div>
</div>

<!-- Instructions link - always shows as ? button -->
<div class="instructions-link">
  <a href="https://mitchell360.com/map-maker/llm.md" target="_blank" title="Instructions for using this Map Maker">?</a>
</div>


<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
  integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
<script>
// Cache-busting removed - was causing page reload/blinking issues
console.log('[Init] Page loading, URL:', window.location.href);

// Utility functions
function qs(name){const u=new URL(location.href);return u.searchParams.get(name);}

// Drawer functionality
const drawer=document.getElementById('drawer');
const drawerBackdrop=document.getElementById('drawerBackdrop');
const drawerContent=document.getElementById('drawerContent');
const drawerHandle=document.getElementById('drawerHandle');

let drawerStartY=0;
let drawerCurrentY=0;
let isDragging=false;

function openDrawer(html){
  drawerContent.innerHTML=html;
  drawer.classList.add('active');
  drawerBackdrop.classList.add('active');
}

function closeDrawer(){
  drawer.classList.remove('active');
  drawerBackdrop.classList.remove('active');
  drawer.style.transform='';
}

// Touch gestures for drawer
drawerHandle.addEventListener('touchstart',e=>{
  isDragging=true;
  drawerStartY=e.touches[0].clientY;
  drawer.style.transition='none';
});

drawerHandle.addEventListener('touchmove',e=>{
  if(!isDragging)return;
  drawerCurrentY=e.touches[0].clientY-drawerStartY;
  if(drawerCurrentY>0){
    drawer.style.transform=`translateY(${drawerCurrentY}px)`;
  }
});

drawerHandle.addEventListener('touchend',e=>{
  if(!isDragging)return;
  isDragging=false;
  drawer.style.transition='';
  if(drawerCurrentY>100){
    closeDrawer();
  }else{
    drawer.style.transform='translateY(0)';
  }
  drawerCurrentY=0;
});

// Click backdrop to close
drawerBackdrop.addEventListener('click',closeDrawer);

// Local coordinate dictionary (loaded from coordinates.json)
let localCoords=null;

// Sailing routes graph for sea routing
let sailingPorts={}; // {portName: {lat, lon}}
let sailingGraph={}; // {portName: [{to, dist}, ...]}

// Calculate straight-line distance between two points (accepts {lat,lon} objects)
function haversineDistance(start,end){
  const R=6371e3;
  const lat1=start.lat*Math.PI/180,lat2=end.lat*Math.PI/180;
  const dLat=(end.lat-start.lat)*Math.PI/180;
  const dLon=(end.lon-start.lon)*Math.PI/180;
  const a=Math.sin(dLat/2)**2+Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLon/2)**2;
  const c=2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a));
  return R*c;
}

// Load local coordinates dictionary
async function loadLocalCoords(){
  try{
    const r=await fetch('coordinates.json');
    if(r.ok){
      const data=await r.json();
      localCoords=data.locations||[];
      console.log(`Loaded ${localCoords.length} local coordinates`);
    }
  }catch(e){console.log('Local coordinates not available, using Nominatim only');}
}

// Load sailing routes and build graph for sea routing (kept for overlay display only)
async function loadSailingGraph(){
  try{
    const r=await fetch('sailing_routes.json');
    if(r.ok){
      const data=await r.json();
      sailingPorts=data.ports||{};
      sailingGraph={};
      for(const portName of Object.keys(sailingPorts)){
        sailingGraph[portName]=[];
      }
      for(const route of (data.routes||[])){
        const from=route.from;
        const to=route.to;
        if(sailingPorts[from]&&sailingPorts[to]){
          const fromP=sailingPorts[from];
          const toP=sailingPorts[to];
          const dist=haversineDistance({lat:fromP.lat,lon:fromP.lon},{lat:toP.lat,lon:toP.lon});
          sailingGraph[from].push({to,dist});
          sailingGraph[to].push({to:from,dist});
        }
      }
      console.log(`Loaded ${Object.keys(sailingPorts).length} sailing ports`);
    }
  }catch(e){console.log('Sailing routes not available');}
}

// ============================================
// ITINER-E GRAPH-BASED ROUTING
// ============================================
let itinereGraph=null;
let itinereAdjLand=null;  // Land-only adjacency
let itinereAdjMixed=null; // Land + sea adjacency

async function loadItinereGraph(){
  try{
    console.log('Loading itiner-e routing graph...');
    const r=await fetch('itinere_graph.json');
    if(!r.ok)throw new Error('Failed to fetch');
    itinereGraph=await r.json();
    
    // Build adjacency lists for routing
    const nodes=itinereGraph.nodes;
    const edges=itinereGraph.edges;
    
    // Initialize adjacency arrays
    itinereAdjLand=Array(nodes.length).fill(null).map(()=>[]);
    itinereAdjMixed=Array(nodes.length).fill(null).map(()=>[]);
    
    for(let i=0;i<edges.length;i++){
      const e=edges[i];
      const edgeData={to:e.to,length:e.length,type:e.type,idx:i};
      const edgeDataReverse={to:e.from,length:e.length,type:e.type,idx:i};
      
      // Mixed adjacency includes all edges
      itinereAdjMixed[e.from].push(edgeData);
      itinereAdjMixed[e.to].push(edgeDataReverse);
      
      // Land adjacency excludes sea lanes AND port connectors (includes land + river)
      // Port edges only appear in mixed mode since they enable land/sea transitions
      if(e.type!=='sea'&&e.type!=='port'){
        itinereAdjLand[e.from].push(edgeData);
        itinereAdjLand[e.to].push(edgeDataReverse);
      }
    }
    
    console.log(`Loaded itiner-e graph: ${nodes.length} nodes, ${edges.length} edges`);
    return true;
  }catch(e){
    console.error('Failed to load itiner-e graph:',e);
    return false;
  }
}

// Haversine distance in km
function haversineKm(lat1,lon1,lat2,lon2){
  const R=6371;
  const dLat=(lat2-lat1)*Math.PI/180;
  const dLon=(lon2-lon1)*Math.PI/180;
  const a=Math.sin(dLat/2)**2+Math.cos(lat1*Math.PI/180)*Math.cos(lat2*Math.PI/180)*Math.sin(dLon/2)**2;
  return R*2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a));
}

// Find nearest node to a coordinate (also returns the adjacent edge type for connector classification)
function snapToNearestNode(lat,lon){
  if(!itinereGraph)return null;
  const nodes=itinereGraph.nodes;
  const cellSize=itinereGraph.cellSize||0.25;
  const spatialIndex=itinereGraph.spatialIndex;
  
  // Check cells around the point
  let bestNode=null;
  let bestDist=Infinity;
  let bestEdgeType='land'; // Track the edge type for connector classification
  const maxSearchRadius=3; // Search up to 3 cells away (~75km)
  
  for(let dCell=0;dCell<=maxSearchRadius;dCell++){
    const cellLat=Math.floor(lat/cellSize);
    const cellLon=Math.floor(lon/cellSize);
    
    // Expand search in a ring pattern
    for(let dy=-dCell;dy<=dCell;dy++){
      for(let dx=-dCell;dx<=dCell;dx++){
        if(dCell>0&&Math.abs(dy)<dCell&&Math.abs(dx)<dCell)continue; // Skip inner cells already checked
        
        const cellKey=`${cellLat+dy},${cellLon+dx}`;
        const edgeIndices=spatialIndex[cellKey];
        if(!edgeIndices)continue;
        
        // Check nodes of edges in this cell
        for(const edgeIdx of edgeIndices){
          const edge=itinereGraph.edges[edgeIdx];
          // Check both endpoints
          for(const nodeId of [edge.from,edge.to]){
            const node=nodes[nodeId];
            const dist=haversineKm(lat,lon,node.lat,node.lon);
            if(dist<bestDist){
              bestDist=dist;
              bestNode={id:nodeId,lat:node.lat,lon:node.lon,dist};
              bestEdgeType=edge.type||'land';
            }
          }
        }
      }
    }
    
    // If found a node within reasonable distance, stop expanding
    if(bestNode&&bestDist<50)break;
  }
  
  if(bestNode)bestNode.edgeType=bestEdgeType;
  return bestNode;
}

// Dijkstra shortest path on itiner-e graph
function dijkstraItinere(startId,endId,useMixed=true){
  const adj=useMixed?itinereAdjMixed:itinereAdjLand;
  if(!adj||startId===null||endId===null)return null;
  
  const nodes=itinereGraph.nodes;
  const n=nodes.length;
  
  const dist=new Float64Array(n).fill(Infinity);
  const prev=new Int32Array(n).fill(-1);
  const prevEdge=new Int32Array(n).fill(-1);
  const visited=new Uint8Array(n);
  
  // Simple priority queue using array (sufficient for this graph size)
  const pq=[{id:startId,d:0}];
  dist[startId]=0;
  
  while(pq.length>0){
    // Get minimum
    let minIdx=0;
    for(let i=1;i<pq.length;i++){
      if(pq[i].d<pq[minIdx].d)minIdx=i;
    }
    const {id:current,d:currentDist}=pq.splice(minIdx,1)[0];
    
    if(visited[current])continue;
    visited[current]=1;
    
    if(current===endId)break;
    
    for(const edge of adj[current]){
      if(visited[edge.to])continue;
      const newDist=dist[current]+edge.length;
      if(newDist<dist[edge.to]){
        dist[edge.to]=newDist;
        prev[edge.to]=current;
        prevEdge[edge.to]=edge.idx;
        pq.push({id:edge.to,d:newDist});
      }
    }
  }
  
  if(dist[endId]===Infinity)return null;
  
  // Reconstruct path with edge geometries
  const pathCoords=[];
  const edgeTypes=[];
  let current=endId;
  const edgeSequence=[];
  
  while(prev[current]!==-1){
    edgeSequence.unshift({from:prev[current],to:current,edgeIdx:prevEdge[current]});
    current=prev[current];
  }
  
  // Build polyline from edge coordinates
  for(const seg of edgeSequence){
    const edge=itinereGraph.edges[seg.edgeIdx];
    let coords=edge.coords;
    
    // Reverse if we're going backwards on this edge
    if(edge.from!==seg.from){
      coords=[...coords].reverse();
    }
    
    // Add coordinates (skip first point if not first segment to avoid duplicates)
    const startIdx=pathCoords.length===0?0:1;
    for(let i=startIdx;i<coords.length;i++){
      pathCoords.push(coords[i]);
    }
    edgeTypes.push(edge.type);
  }
  
  // Add end node if path is empty
  if(pathCoords.length===0){
    const endNode=nodes[endId];
    pathCoords.push([endNode.lat,endNode.lon]);
  }
  
  // Calculate land vs sea distance breakdown
  let landDist=0,seaDist=0;
  for(const seg of edgeSequence){
    const edge=itinereGraph.edges[seg.edgeIdx];
    if(edge.type==='sea'){
      seaDist+=edge.length;
    }else{
      landDist+=edge.length;
    }
  }
  
  return{
    coords:pathCoords,
    distance:dist[endId]*1000, // Convert to meters for compatibility
    edgeTypes,
    hasSeaSegments:edgeTypes.includes('sea'),
    landDistKm:landDist,
    seaDistKm:seaDist
  };
}

// Get route using itiner-e graph (replaces OSRM)
async function getItinereRoute(start,end,useMixed=true){
  if(!itinereGraph){
    console.warn('Itiner-e graph not loaded');
    return null;
  }
  
  const startNode=snapToNearestNode(start.lat,start.lon);
  const endNode=snapToNearestNode(end.lat,end.lon);
  
  if(!startNode||!endNode){
    console.warn('Could not snap to itiner-e network');
    return null;
  }
  
  // Warn if snap distance is too far (>50km)
  if(startNode.dist>50||endNode.dist>50){
    console.warn(`Large snap distance: start=${startNode.dist.toFixed(1)}km, end=${endNode.dist.toFixed(1)}km`);
  }
  
  const result=dijkstraItinere(startNode.id,endNode.id,useMixed);
  if(!result)return null;
  
  // Add connector legs from actual start/end to snapped nodes
  const fullCoords=[[start.lat,start.lon],...result.coords,[end.lat,end.lon]];
  
  // Connector distances are always treated as land travel (walking to/from network)
  // This is semantically correct: you walk to the Roman road or port, then the network routing takes over
  const connectorDistKm=startNode.dist+endNode.dist;
  
  // Validation: total should approximately equal landDistKm + seaDistKm + connectors
  const totalRouteKm=result.landDistKm+result.seaDistKm;
  const expectedTotalKm=totalRouteKm+connectorDistKm;
  const reportedDistKm=result.distance/1000+connectorDistKm;
  if(Math.abs(expectedTotalKm-reportedDistKm)>1){
    console.warn(`Route distance mismatch: expected ${expectedTotalKm.toFixed(1)}km, got ${reportedDistKm.toFixed(1)}km`);
  }
  
  return{
    distance:result.distance+connectorDistKm*1000,
    geometry:{type:'LineString',coordinates:fullCoords.map(c=>[c[1],c[0]])}, // [lon,lat] for GeoJSON
    hasSeaSegments:result.hasSeaSegments,
    edgeTypes:result.edgeTypes,
    landDistKm:result.landDistKm+connectorDistKm, // Connectors always land (walking to/from network)
    seaDistKm:result.seaDistKm,
    isFallback:false
  };
}

// OSRM fallback routing for locations outside Roman road network
async function getOSRMRoute(start,end){
  try{
    const url=`https://router.project-osrm.org/route/v1/foot/${start.lon},${start.lat};${end.lon},${end.lat}?overview=full&geometries=geojson`;
    console.log('[Routing] Trying OSRM fallback for route outside Roman network');
    const response=await fetch(url);
    if(!response.ok){
      console.warn('[Routing] OSRM request failed:',response.status);
      return null;
    }
    const data=await response.json();
    if(data.code!=='Ok'||!data.routes||data.routes.length===0){
      console.warn('[Routing] OSRM returned no route');
      return null;
    }
    const route=data.routes[0];
    const distanceKm=route.distance/1000;
    console.log(`[Routing] OSRM fallback route: ${distanceKm.toFixed(1)} km`);
    return{
      distance:route.distance,
      geometry:route.geometry,
      hasSeaSegments:false,
      edgeTypes:{land:1},
      landDistKm:distanceKm,
      seaDistKm:0,
      isFallback:true // Flag to indicate this is a modern road approximation
    };
  }catch(err){
    console.error('[Routing] OSRM fallback error:',err);
    return null;
  }
}

// Get route with fallback: try Roman roads first, then OSRM
async function getRouteWithFallback(start,end,useMixed=true){
  // Try itiner-e Roman road routing first
  const romanRoute=await getItinereRoute(start,end,useMixed);
  if(romanRoute&&romanRoute.distance>0){
    return romanRoute;
  }
  // Fallback to OSRM modern routing
  console.log('[Routing] Roman road routing failed, trying OSRM fallback');
  return await getOSRMRoute(start,end);
}

// Find nearest port to a coordinate
function findNearestPort(coord){
  let nearest=null;
  let minDist=Infinity;
  for(const [name,port] of Object.entries(sailingPorts)){
    const dist=haversineDistance(coord,{lat:port.lat,lon:port.lon});
    if(dist<minDist){
      minDist=dist;
      nearest={name,lat:port.lat,lon:port.lon,dist};
    }
  }
  return nearest;
}

// Dijkstra shortest path between two ports
function dijkstraSeaPath(startPort,endPort){
  if(!sailingGraph[startPort]||!sailingGraph[endPort])return null;
  
  const dist={};
  const prev={};
  const visited=new Set();
  const pq=[{port:startPort,dist:0}];
  
  for(const port of Object.keys(sailingGraph)){
    dist[port]=Infinity;
  }
  dist[startPort]=0;
  
  while(pq.length>0){
    // Get minimum distance node
    pq.sort((a,b)=>a.dist-b.dist);
    const {port:current}=pq.shift();
    
    if(visited.has(current))continue;
    visited.add(current);
    
    if(current===endPort)break;
    
    for(const edge of sailingGraph[current]){
      if(visited.has(edge.to))continue;
      const newDist=dist[current]+edge.dist;
      if(newDist<dist[edge.to]){
        dist[edge.to]=newDist;
        prev[edge.to]=current;
        pq.push({port:edge.to,dist:newDist});
      }
    }
  }
  
  if(dist[endPort]===Infinity)return null;
  
  // Reconstruct path
  const path=[];
  let current=endPort;
  while(current){
    const port=sailingPorts[current];
    path.unshift({name:current,lat:port.lat,lon:port.lon});
    current=prev[current];
  }
  
  return{path,distance:dist[endPort]};
}

// Get sea route between two arbitrary coordinates
function getSeaRoute(start,end){
  const startPort=findNearestPort(start);
  const endPort=findNearestPort(end);
  
  if(!startPort||!endPort)return null;
  
  // If ports are too far from coordinates (>200km), not a valid sea route
  if(startPort.dist>200000||endPort.dist>200000)return null;
  
  // Same port - no sea routing needed
  if(startPort.name===endPort.name)return null;
  
  const result=dijkstraSeaPath(startPort.name,endPort.name);
  if(!result)return null;
  
  // Build full path: start coord -> start port -> ... -> end port -> end coord
  const fullPath=[{lat:start.lat,lon:start.lon}];
  for(const port of result.path){
    fullPath.push({lat:port.lat,lon:port.lon});
  }
  fullPath.push({lat:end.lat,lon:end.lon});
  
  // Calculate total distance including connector legs
  let totalDist=result.distance;
  totalDist+=startPort.dist; // Start to embark port
  totalDist+=endPort.dist;   // Disembark port to end
  
  return{path:fullPath,distance:totalDist,startPort:startPort.name,endPort:endPort.name};
}

// Normalize location string for matching
function normalizeLocation(q){
  return q.toLowerCase().trim().replace(/\s+/g,' ').replace(/,\s*/g,',');
}

// Check local dictionary for coordinates
function lookupLocalCoords(q){
  if(!localCoords)return null;
  const normalized=normalizeLocation(q);
  for(const loc of localCoords){
    for(const name of loc.names){
      if(normalizeLocation(name)===normalized){
        return{lat:loc.lat,lon:loc.lon,display:name+' (local)'};
      }
    }
  }
  return null;
}

// Validate coordinates are within biblical/ancient world bounds
// Rejects obviously wrong geocoding results (e.g., Atlantic Ocean, Americas)
function isValidAncientWorldCoord(lat,lon){
  // Expanded ancient world bounds: 0-60N, 30W-80E
  // Covers: Mediterranean, Middle East, Mesopotamia, Egypt, Persia, Arabia, Ethiopia, India
  const minLat=0,maxLat=60,minLon=-30,maxLon=80;
  return lat>=minLat&&lat<=maxLat&&lon>=minLon&&lon<=maxLon;
}

// Geocoding - check local dictionary first, then Nominatim
async function geocode(q){
  // Check local dictionary first (instant)
  const local=lookupLocalCoords(q);
  if(local)return local;
  
  // Fall back to Nominatim API (rate-limited)
  const url='https://nominatim.openstreetmap.org/search?format=json&limit=1&q='+encodeURIComponent(q);
  const r=await fetch(url,{headers:{'Accept-Language':'en','User-Agent':'URL-Map/1.0'}});
  if(!r.ok)return null;
  const j=await r.json();
  if(j&&j.length){
    const lat=parseFloat(j[0].lat);
    const lon=parseFloat(j[0].lon);
    // Validate result is within ancient world region
    if(!isValidAncientWorldCoord(lat,lon)){
      console.warn(`Geocoding rejected for "${q}": coordinates (${lat},${lon}) outside ancient world bounds. Use @lat,lon syntax for precise placement.`);
      return null; // Reject bad coordinates
    }
    return{lat,lon,display:j[0].display_name};
  }
  return null;
}

// Loading indicator helpers
const loadingOverlay=document.getElementById('loadingOverlay');
const loadingText=document.getElementById('loadingText');
const loadingDetail=document.getElementById('loadingDetail');

function updateLoading(text,detail=''){
  loadingText.textContent=text;
  loadingDetail.textContent=detail;
}

function hideLoading(){
  loadingOverlay.style.display='none';
}

// Initialize map
(async function(){
  updateLoading('Initializing map...');
  
  // Load local coordinates dictionary first (for fast geocoding)
  await loadLocalCoords();
  
  // Load itiner-e routing graph
  updateLoading('Loading routing network...');
  await loadItinereGraph();
  
  // Load sailing routes for overlay display (kept for Mendeley overlay, not routing)
  await loadSailingGraph();
  
  const map=L.map('map',{zoomControl:true}).setView([20,0],2);
  
  // Create custom pane for journey markers (user's locations) with high z-index
  map.createPane('journeyPane');
  map.getPane('journeyPane').style.zIndex=650; // Above markers (600) and overlays
  
  // Create separate pane for journey labels (tooltips) above markers
  map.createPane('journeyLabelPane');
  map.getPane('journeyLabelPane').style.zIndex=700; // Above journey markers
  
  // Base map layers
  const dareBackground=L.tileLayer('https://klokantech.github.io/dare-raster-tiles/background/{z}/{x}/{y}.png',{minZoom:0,maxZoom:11,attribution:'© DARE Background'});
  const dareHillshade=L.tileLayer('https://klokantech.github.io/dare-raster-tiles/hillshade/{z}/{x}/{y}.png',{minZoom:0,maxZoom:11,opacity:0.4});
  const dareTerrain=L.layerGroup([dareBackground,dareHillshade]); // Combined terrain with hillshade
  dareTerrain.addTo(map);
  
  const dareFull=L.tileLayer('https://dh.gu.se/tiles/imperium/{z}/{x}/{y}.png',{minZoom:4,maxZoom:11,attribution:'© <a href="https://dh.gu.se/dare/">Digital Atlas of the Roman Empire</a>'});
  const positron=L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png',{maxZoom:19,attribution:'© OpenStreetMap © CartoDB'});
  const osm=L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:19,attribution:'© OpenStreetMap'});
  
  let currentBaseMap='terrain';
  const baseMaps={terrain:dareTerrain,full:dareFull,positron:positron,osm:osm};
  
  // Check if ANY URL parameters exist (excluding cache-buster)
  const urlParamsRaw=new URLSearchParams(window.location.search);
  urlParamsRaw.delete('_cb');
  const hasAnyParams=urlParamsRaw.toString().length>0;
  
  // Add title - only use default when NO URL parameters at all
  const titleParam=qs('title');
  const defaultTitle="Sample: Paul's Missionary Journeys";
  const displayTitle=hasAnyParams?(titleParam||''):defaultTitle;
  
  if(displayTitle){
    const titleDiv=document.createElement('div');
    titleDiv.className='map-title';
    titleDiv.textContent=displayTitle;
    document.body.appendChild(titleDiv);
  }
  
  // Custom marker icons
  const blueIcon=L.icon({iconUrl:'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-blue.png',shadowUrl:'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',iconSize:[25,41],iconAnchor:[12,41],popupAnchor:[1,-34],shadowSize:[41,41]});
  const redIcon=L.icon({iconUrl:'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',shadowUrl:'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',iconSize:[25,41],iconAnchor:[12,41],popupAnchor:[1,-34],shadowSize:[41,41]});
  
  // Create overlay layers - Your Journey
  const countryBorders=L.layerGroup();
  const travelLineAndTime=L.layerGroup();
  const romanRoads=L.layerGroup();
  const seaLanes=L.layerGroup();
  const sailingRoutes=L.layerGroup();
  
  // Create overlay layers - Ancient World
  const ancientPlaces=L.layerGroup();  // All cities (places_medium)
  const majorCities=L.layerGroup();    // Major cities only (places_low)
  const famousCities=L.layerGroup();   // Famous cities only (curated 50)
  const romanProvinces=L.layerGroup();  // Provinces with names
  const ancientRivers=L.layerGroup();
  const ancientLakes=L.layerGroup();
  const ancientAqueducts=L.layerGroup();
  const ancientFortifications=L.layerGroup();
  const ancientBridges=L.layerGroup();
  const ancientSeas=L.layerGroup();
  
  // Track which layers are loaded
  const layerLoadState={
    places:false,majorCities:false,famousCities:false,provinces:false,
    rivers:false,lakes:false,aqueducts:false,fortifications:false,bridges:false,seas:false
  };
  
  // Label language setting
  let labelLanguage='latin'; // 'latin', 'modern', 'greek'
  
  // Add invisible placeholder so layer shows in control
  travelLineAndTime.addLayer(L.circle([0,0],{radius:1,opacity:0}));
  romanRoads.addLayer(L.circle([0,0],{radius:1,opacity:0}));
  seaLanes.addLayer(L.circle([0,0],{radius:1,opacity:0}));
  sailingRoutes.addLayer(L.circle([0,0],{radius:1,opacity:0}));
  
  // Load country borders from local file
  fetch('country_borders.geojson')
    .then(r=>r.json())
    .then(data=>{
      L.geoJSON(data,{
        style:{
          color:'#1f2937',
          weight:2.5,
          opacity:0.8,
          fillOpacity:0
        }
      }).addTo(countryBorders);
    })
    .catch(e=>console.error('Border load error:',e));
  
  // Load Roman roads from local file (downloaded from itiner-e.org)
  let romanRoadsLoaded=false;
  let seaLanesLoaded=false;
  let roadDataCache=null;
  
  function fetchRoadData(){
    if(roadDataCache)return Promise.resolve(roadDataCache);
    return fetch('roman_roads.ndjson')
      .then(r=>r.text())
      .then(text=>{
        const lines=text.trim().split('\n');
        const features=[];
        for(const line of lines){
          try{
            const feature=JSON.parse(line);
            features.push(feature);
          }catch(e){}
        }
        roadDataCache=features;
        return features;
      });
  }
  
  function loadRomanRoads(){
    if(romanRoadsLoaded)return;
    romanRoadsLoaded=true;
    
    fetchRoadData().then(features=>{
        // Filter out Sea Lanes - only show land roads
        const landRoads=features.filter(f=>f.properties&&f.properties.type!=='Sea Lane'&&f.properties.type!=='River');
        
        // Style roads by type and certainty
        function getRoadStyle(props){
          const isMain=props.type==='Main Road';
          const certainty=props.segmentCertainty||'Conjectured';
          
          let color='#8B4513'; // Default brown for roman roads
          let weight=isMain?2.5:1.5;
          let opacity=0.8;
          let dashArray=null;
          
          if(certainty==='Certain'){
            color=isMain?'#8B4513':'#A0522D'; // Darker brown for certain roads
            opacity=0.9;
          }else if(certainty==='Conjectured'){
            color=isMain?'#CD853F':'#D2691E'; // Lighter brown for conjectured
            opacity=0.7;
          }else if(certainty==='Hypothetical'){
            color='#DEB887';
            opacity=0.5;
            dashArray='4,4';
          }
          
          return{color,weight,opacity,dashArray};
        }
        
        // Create GeoJSON layer for land roads only
        const roadsLayer=L.geoJSON({type:'FeatureCollection',features:landRoads},{
          style:f=>getRoadStyle(f.properties),
          onEachFeature:(f,layer)=>{
            const props=f.properties;
            const name=props.name||'Roman Road';
            const type=props.type||'Road';
            const certainty=props.segmentCertainty||'Unknown';
            const length=(props._lengthInKm||0).toFixed(2);
            const period=props.constructionPeriod||'Unknown period';
            layer.bindPopup(`<b>${name}</b><br>Type: ${type}<br>Certainty: ${certainty}<br>Length: ${length} km<br>Period: ${period}`);
          }
        });
        
        romanRoads.clearLayers();
        romanRoads.addLayer(roadsLayer);
        console.log(`Loaded ${landRoads.length} Roman road segments (land only)`);
      })
      .catch(e=>console.error('Roman roads load error:',e));
  }
  
  // Load sea lanes/sailing routes
  function loadSeaLanes(){
    if(seaLanesLoaded)return;
    seaLanesLoaded=true;
    
    fetchRoadData().then(features=>{
        // Filter to Sea Lanes and Rivers only
        const waterRoutes=features.filter(f=>f.properties&&(f.properties.type==='Sea Lane'||f.properties.type==='River'));
        
        // Create GeoJSON layer for sea routes with distinct styling
        const seaLayer=L.geoJSON({type:'FeatureCollection',features:waterRoutes},{
          style:f=>{
            const isRiver=f.properties.type==='River';
            return{
              color:isRiver?'#2563eb':'#0ea5e9', // Blue for rivers, cyan for sea lanes
              weight:isRiver?2:2.5,
              opacity:0.7,
              dashArray:isRiver?null:'6,4' // Dashed for sea lanes
            };
          },
          onEachFeature:(f,layer)=>{
            const props=f.properties;
            const name=props.name||'Sea Route';
            const type=props.type||'Route';
            const length=(props._lengthInKm||0).toFixed(2);
            layer.bindPopup(`<b>${name}</b><br>Type: ${type}<br>Length: ${length} km`);
          }
        });
        
        seaLanes.clearLayers();
        seaLanes.addLayer(seaLayer);
        console.log(`Loaded ${waterRoutes.length} sea lanes and river routes`);
      })
      .catch(e=>console.error('Sea lanes load error:',e));
  }
  
  // Load Mendeley sailing routes from JSON (ancient Mediterranean shipping network)
  let sailingRoutesLoaded=false;
  function loadSailingRoutes(){
    if(sailingRoutesLoaded)return;
    sailingRoutesLoaded=true;
    
    fetch('sailing_routes.json')
      .then(r=>r.json())
      .then(data=>{
        const ports=data.ports;
        const routes=data.routes;
        
        // Create port markers (small circles)
        const portMarkers=[];
        for(const [name,info] of Object.entries(ports)){
          const marker=L.circleMarker([info.lat,info.lon],{
            radius:5,
            fillColor:'#0ea5e9',
            color:'#0369a1',
            weight:2,
            opacity:1,
            fillOpacity:0.8
          });
          marker.bindPopup(`<b>${name}</b><br><span style="color:#6b7280">${info.modern}</span><br><span style="font-size:11px">Ancient Mediterranean Port</span>`);
          portMarkers.push(marker);
        }
        
        // Create route lines
        const routeLines=[];
        for(const route of routes){
          const fromPort=ports[route.from];
          const toPort=ports[route.to];
          if(fromPort&&toPort){
            const line=L.polyline([[fromPort.lat,fromPort.lon],[toPort.lat,toPort.lon]],{
              color:'#0ea5e9',
              weight:1.5,
              opacity:0.5,
              dashArray:'4,6'
            });
            line.bindPopup(`<b>${route.from} ↔ ${route.to}</b><br><span style="font-size:11px;color:#6b7280">Ancient sailing route (Mendeley research data)</span>`);
            routeLines.push(line);
          }
        }
        
        sailingRoutes.clearLayers();
        routeLines.forEach(l=>sailingRoutes.addLayer(l));
        portMarkers.forEach(m=>sailingRoutes.addLayer(m));
        console.log(`Loaded ${Object.keys(ports).length} ancient ports and ${routes.length} sailing routes`);
      })
      .catch(e=>console.error('Sailing routes load error:',e));
  }
  
  // Load Ancient Places from data file
  function loadAncientPlaces(){
    if(layerLoadState.places)return;
    layerLoadState.places=true;
    fetch('data/places_medium.geojson')
      .then(r=>r.json())
      .then(data=>{
        const layer=L.geoJSON(data,{
          pointToLayer:(f,latlng)=>{
            const major=f.properties.major===1;
            return L.circleMarker(latlng,{
              radius:major?6:4,
              fillColor:major?'#dc2626':'#f59e0b',
              color:'#fff',
              weight:1,
              opacity:1,
              fillOpacity:0.8
            });
          },
          onEachFeature:(f,layer)=>{
            const p=f.properties;
            const name=labelLanguage==='latin'?p.latin:(labelLanguage==='greek'&&p.greek?p.greek:p.modern);
            const displayName=name||p.latin||p.modern||'Unknown';
            layer.bindPopup(`<b>${displayName}</b><br><span style="color:#6b7280">Latin: ${p.latin||'—'}<br>Modern: ${p.modern||'—'}</span>`);
          }
        });
        ancientPlaces.clearLayers();
        ancientPlaces.addLayer(layer);
        console.log(`Loaded ${data.features.length} ancient places`);
      }).catch(e=>console.error('Places load error:',e));
  }
  
  // Load Rivers
  function loadAncientRivers(){
    if(layerLoadState.rivers)return;
    layerLoadState.rivers=true;
    fetch('data/rivers.geojson')
      .then(r=>r.json())
      .then(data=>{
        const layer=L.geoJSON(data,{
          style:{color:'#3b82f6',weight:1.5,opacity:0.7},
          onEachFeature:(f,layer)=>{
            const p=f.properties;
            const name=p.latin||p.name||p.modern||'River';
            layer.bindPopup(`<b>${name}</b><br><span style="color:#6b7280">${p.modern||''}</span>`);
          }
        });
        ancientRivers.clearLayers();
        ancientRivers.addLayer(layer);
        console.log(`Loaded rivers`);
      }).catch(e=>console.error('Rivers load error:',e));
  }
  
  // Load Lakes
  function loadAncientLakes(){
    if(layerLoadState.lakes)return;
    layerLoadState.lakes=true;
    fetch('data/lakes.geojson')
      .then(r=>r.json())
      .then(data=>{
        const layer=L.geoJSON(data,{
          style:{color:'#0ea5e9',weight:1,opacity:0.7,fillOpacity:0.3,fillColor:'#0ea5e9'},
          onEachFeature:(f,layer)=>{
            const p=f.properties;
            const name=p.latin||p.name||p.modern||'Lake';
            layer.bindPopup(`<b>${name}</b><br><span style="color:#6b7280">${p.modern||''}</span>`);
          }
        });
        ancientLakes.clearLayers();
        ancientLakes.addLayer(layer);
        console.log(`Loaded lakes`);
      }).catch(e=>console.error('Lakes load error:',e));
  }
  
  // Load Aqueducts
  function loadAncientAqueducts(){
    if(layerLoadState.aqueducts)return;
    layerLoadState.aqueducts=true;
    fetch('data/aqueducts.geojson')
      .then(r=>r.json())
      .then(data=>{
        const layer=L.geoJSON(data,{
          style:{color:'#0d9488',weight:2,opacity:0.8,dashArray:'4,4'},
          onEachFeature:(f,layer)=>{
            const p=f.properties;
            layer.bindPopup(`<b>Aqueduct</b><br><span style="color:#6b7280">${p.Name||p.en_name||'Roman Aqueduct'}</span>`);
          }
        });
        ancientAqueducts.clearLayers();
        ancientAqueducts.addLayer(layer);
        console.log(`Loaded aqueducts`);
      }).catch(e=>console.error('Aqueducts load error:',e));
  }
  
  // Load Fortifications
  function loadAncientFortifications(){
    if(layerLoadState.fortifications)return;
    layerLoadState.fortifications=true;
    fetch('data/fortifications.geojson')
      .then(r=>r.json())
      .then(data=>{
        const layer=L.geoJSON(data,{
          pointToLayer:(f,latlng)=>L.circleMarker(latlng,{radius:4,fillColor:'#64748b',color:'#1e293b',weight:1,opacity:1,fillOpacity:0.8}),
          style:{color:'#64748b',weight:2,opacity:0.8},
          onEachFeature:(f,layer)=>{
            const p=f.properties;
            layer.bindPopup(`<b>${p.name||'Fortification'}</b>`);
          }
        });
        ancientFortifications.clearLayers();
        ancientFortifications.addLayer(layer);
        console.log(`Loaded fortifications`);
      }).catch(e=>console.error('Fortifications load error:',e));
  }
  
  // Load Major Cities (places_low.geojson - 1523 major settlements)
  function loadMajorCities(){
    if(layerLoadState.majorCities)return;
    layerLoadState.majorCities=true;
    fetch('data/places_low.geojson')
      .then(r=>r.json())
      .then(data=>{
        const layer=L.geoJSON(data,{
          pointToLayer:(f,latlng)=>{
            const major=f.properties.major===1;
            return L.circleMarker(latlng,{
              radius:major?6:4,
              fillColor:major?'#dc2626':'#f59e0b',
              color:'#fff',
              weight:1,
              opacity:1,
              fillOpacity:0.8
            });
          },
          onEachFeature:(f,layer)=>{
            const p=f.properties;
            const name=labelLanguage==='latin'?p.latin:(labelLanguage==='greek'&&p.greek?p.greek:p.modern);
            const displayName=name||p.latin||p.modern||'Unknown';
            layer.bindPopup(`<b>${displayName}</b><br><span style="color:#6b7280">Latin: ${p.latin||'—'}<br>Modern: ${p.modern||'—'}</span>`);
          }
        });
        majorCities.clearLayers();
        majorCities.addLayer(layer);
        console.log(`Loaded ${data.features.length} major cities`);
      }).catch(e=>console.error('Major cities load error:',e));
  }
  
  // Load Famous Cities (curated 50 most important ancient cities)
  function loadFamousCities(){
    if(layerLoadState.famousCities)return;
    layerLoadState.famousCities=true;
    fetch('data/famous_cities.geojson')
      .then(r=>r.json())
      .then(data=>{
        const layer=L.geoJSON(data,{
          pointToLayer:(f,latlng)=>{
            const p=f.properties;
            const name=p.latin||p.modern||'?';
            return L.marker(latlng,{
              icon:L.divIcon({
                className:'famous-city-marker',
                html:`<div style="position:relative">
                  <div style="width:12px;height:12px;background:#b91c1c;border:2px solid #fff;border-radius:50%;box-shadow:0 1px 3px rgba(0,0,0,0.4)"></div>
                  <div style="position:absolute;top:-18px;left:50%;transform:translateX(-50%);white-space:nowrap;font-size:11px;font-weight:600;color:#7f1d1d;text-shadow:1px 1px 1px white,-1px -1px 1px white,1px -1px 1px white,-1px 1px 1px white">${name}</div>
                </div>`,
                iconSize:[12,12],
                iconAnchor:[6,6]
              })
            });
          },
          onEachFeature:(f,layer)=>{
            const p=f.properties;
            const latinName=p.latin||'—';
            const modernName=p.modern||'—';
            const greekName=p.greek||'—';
            layer.bindPopup(`
              <div style="min-width:150px">
                <div style="font-size:16px;font-weight:600;color:#1f2937;margin-bottom:8px">${latinName}</div>
                <div style="color:#6b7280;font-size:12px;line-height:1.6">
                  <div><span style="color:#374151;font-weight:500">Latin:</span> ${latinName}</div>
                  <div><span style="color:#374151;font-weight:500">Modern:</span> ${modernName}</div>
                  ${greekName!=='—'?`<div><span style="color:#374151;font-weight:500">Greek:</span> ${greekName}</div>`:''}
                </div>
              </div>
            `);
          }
        });
        famousCities.clearLayers();
        famousCities.addLayer(layer);
        console.log(`Loaded ${data.features.length} famous cities`);
      }).catch(e=>console.error('Famous cities load error:',e));
  }
  
  // Load Bridges
  function loadAncientBridges(){
    if(layerLoadState.bridges)return;
    layerLoadState.bridges=true;
    fetch('data/bridges.geojson')
      .then(r=>r.json())
      .then(data=>{
        const layer=L.geoJSON(data,{
          pointToLayer:(f,latlng)=>L.circleMarker(latlng,{radius:5,fillColor:'#92400e',color:'#78350f',weight:2,opacity:1,fillOpacity:0.8}),
          onEachFeature:(f,layer)=>{
            const p=f.properties;
            const name=p.latin||p.modern||'Roman Bridge';
            layer.bindPopup(`<b>${name}</b><br><span style="color:#6b7280">${p.modern||''}</span>`);
          }
        });
        ancientBridges.clearLayers();
        ancientBridges.addLayer(layer);
        console.log(`Loaded ${data.features.length} bridges`);
      }).catch(e=>console.error('Bridges load error:',e));
  }
  
  // Load Seas (labels for major ancient seas)
  function loadAncientSeas(){
    if(layerLoadState.seas)return;
    layerLoadState.seas=true;
    fetch('data/seas.geojson')
      .then(r=>r.json())
      .then(data=>{
        const layer=L.geoJSON(data,{
          pointToLayer:(f,latlng)=>{
            const p=f.properties;
            const displayName=p.latin||p.modern||'Sea';
            return L.marker(latlng,{
              icon:L.divIcon({
                className:'sea-label',
                html:`<div style="font-family:Georgia,serif;font-style:italic;font-size:14px;color:#0369a1;text-shadow:1px 1px 2px white,-1px -1px 2px white,1px -1px 2px white,-1px 1px 2px white;white-space:nowrap;cursor:pointer">${displayName}</div>`,
                iconSize:[0,0],
                iconAnchor:[0,0]
              }),
              interactive:true
            });
          },
          onEachFeature:(f,layer)=>{
            const p=f.properties;
            const latinName=p.latin||'—';
            const modernName=p.modern||'—';
            layer.bindPopup(`
              <div style="min-width:120px">
                <div style="font-size:15px;font-weight:600;color:#0369a1;font-style:italic">${latinName}</div>
                <div style="color:#6b7280;font-size:12px;margin-top:4px">
                  <div><span style="color:#374151;font-weight:500">Latin:</span> ${latinName}</div>
                  <div><span style="color:#374151;font-weight:500">Modern:</span> ${modernName}</div>
                </div>
              </div>
            `);
          }
        });
        ancientSeas.clearLayers();
        ancientSeas.addLayer(layer);
        console.log(`Loaded ${data.features.length} sea labels`);
      }).catch(e=>console.error('Seas load error:',e));
  }
  
  // Load Province boundaries (with names from klokantech dataset)
  function loadProvinces(){
    if(layerLoadState.provinces)return;
    layerLoadState.provinces=true;
    
    // Load province boundaries (with names)
    fetch('data/provinces_klokan.geojson')
      .then(r=>r.json())
      .then(data=>{
        const layer=L.geoJSON(data,{
          style:{color:'#7c3aed',weight:2,opacity:0.7,fillOpacity:0.08,fillColor:'#7c3aed'},
          onEachFeature:(f,layer)=>{
            const p=f.properties;
            const name=p.name||'Province';
            layer.bindPopup(`<div style="min-width:120px"><div style="font-size:15px;font-weight:600;color:#1f2937">${name}</div><div style="color:#6b7280;font-size:11px;margin-top:4px">Roman Province</div></div>`);
          }
        });
        romanProvinces.clearLayers();
        romanProvinces.addLayer(layer);
        console.log(`Loaded ${data.features.length} provinces`);
      }).catch(e=>console.error('Provinces load error:',e));
    
    // Also load province labels for permanent display
    fetch('data/provinces_labels.geojson')
      .then(r=>r.json())
      .then(data=>{
        const labelLayer=L.geoJSON(data,{
          pointToLayer:(f,latlng)=>{
            const name=f.properties.name||'';
            return L.marker(latlng,{
              icon:L.divIcon({
                className:'province-label',
                html:`<div style="font-family:Georgia,serif;font-size:11px;color:#5b21b6;text-shadow:1px 1px 1px white,-1px -1px 1px white;white-space:nowrap;font-weight:500">${name}</div>`,
                iconSize:[0,0],
                iconAnchor:[0,0]
              }),
              interactive:false
            });
          }
        });
        romanProvinces.addLayer(labelLayer);
        console.log(`Loaded ${data.features.length} province labels`);
      }).catch(e=>console.error('Province labels load error:',e));
  }
  
  // Load layers when overlay is added
  map.on('overlayadd',function(e){
    console.log('[OverlayAdd] Layer added:', e.layer);
    if(e.layer===romanRoads)loadRomanRoads();
    if(e.layer===seaLanes)loadSeaLanes();
    if(e.layer===sailingRoutes)loadSailingRoutes();
    if(e.layer===ancientPlaces)loadAncientPlaces();
    if(e.layer===majorCities)loadMajorCities();
    if(e.layer===famousCities)loadFamousCities();
    if(e.layer===romanProvinces)loadProvinces();
    if(e.layer===ancientRivers)loadAncientRivers();
    if(e.layer===ancientLakes)loadAncientLakes();
    if(e.layer===ancientAqueducts)loadAncientAqueducts();
    if(e.layer===ancientFortifications)loadAncientFortifications();
    if(e.layer===ancientBridges)loadAncientBridges();
    if(e.layer===ancientSeas)loadAncientSeas();
  });
  
  map.on('overlayremove',function(e){
    console.log('[OverlayRemove] Layer removed:', e.layer);
  });
  
  // Build custom layer control panel
  function buildLayerPanel(){
    console.log('[LayerPanel] Building layer panel...');
    const panel=document.createElement('div');
    panel.className='layer-panel';
    panel.innerHTML=`
      <div class="layer-panel-header" onclick="this.parentElement.classList.toggle('collapsed')">
        <h3>Layers</h3>
        <span class="layer-panel-toggle">▼</span>
      </div>
      <div class="layer-panel-content">
        <div class="layer-section">
          <div class="layer-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
            <span class="layer-section-icon">🗺️</span>Base Map
            <span class="layer-section-arrow">▼</span>
          </div>
          <div class="layer-section-items">
            <div class="base-map-item"><input type="radio" name="basemap" value="terrain" checked><label>Ancient Terrain</label></div>
            <div class="base-map-item"><input type="radio" name="basemap" value="full"><label>Ancient Full (DARE)</label></div>
            <div class="base-map-item"><input type="radio" name="basemap" value="positron"><label>Modern Clean</label></div>
            <div class="base-map-item"><input type="radio" name="basemap" value="osm"><label>Modern Detailed</label></div>
          </div>
        </div>
        <div class="layer-section">
          <div class="layer-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
            <span class="layer-section-icon">📍</span>Your Journey
            <span class="layer-section-arrow">▼</span>
          </div>
          <div class="layer-section-items">
            <div class="layer-item"><input type="checkbox" id="layer-travel" checked><label for="layer-travel">Route & Travel Time</label></div>
          </div>
        </div>
        <div class="layer-section">
          <div class="layer-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
            <span class="layer-section-icon">🏛️</span>Roman Infrastructure
            <span class="layer-section-arrow">▼</span>
          </div>
          <div class="layer-section-items">
            <div class="layer-item"><input type="checkbox" id="layer-roads"><label for="layer-roads">Roman Roads</label></div>
            <div class="layer-item"><input type="checkbox" id="layer-sealanes"><label for="layer-sealanes">Sea Lanes</label></div>
            <div class="layer-item"><input type="checkbox" id="layer-bridges"><label for="layer-bridges">Bridges</label></div>
            <div class="layer-item"><input type="checkbox" id="layer-aqueducts"><label for="layer-aqueducts">Aqueducts</label></div>
          </div>
        </div>
        <div class="layer-section">
          <div class="layer-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
            <span class="layer-section-icon">🏘️</span>Settlements
            <span class="layer-section-arrow">▼</span>
          </div>
          <div class="layer-section-items">
            <div class="layer-item"><input type="checkbox" id="layer-famous-cities" checked><label for="layer-famous-cities">Famous Cities <span class="layer-item-sub">(50)</span></label></div>
            <div class="layer-item"><input type="checkbox" id="layer-major-cities"><label for="layer-major-cities">Major Cities <span class="layer-item-sub">(1.5k)</span></label></div>
            <div class="layer-item"><input type="checkbox" id="layer-all-cities"><label for="layer-all-cities">All Cities <span class="layer-item-sub">(16k+)</span></label></div>
            <div class="layer-item"><input type="checkbox" id="layer-forts"><label for="layer-forts">Fortifications</label></div>
          </div>
        </div>
        <div class="layer-section collapsed">
          <div class="layer-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
            <span class="layer-section-icon">🏛️</span>Political
            <span class="layer-section-arrow">▼</span>
          </div>
          <div class="layer-section-items">
            <div class="layer-item"><input type="checkbox" id="layer-provinces"><label for="layer-provinces">Roman Provinces</label></div>
            <div class="layer-item"><input type="checkbox" id="layer-borders"><label for="layer-borders">Modern Borders</label></div>
          </div>
        </div>
        <div class="layer-section">
          <div class="layer-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
            <span class="layer-section-icon">💧</span>Water Features
            <span class="layer-section-arrow">▼</span>
          </div>
          <div class="layer-section-items">
            <div class="layer-item"><input type="checkbox" id="layer-rivers" checked><label for="layer-rivers">Rivers</label></div>
            <div class="layer-item"><input type="checkbox" id="layer-lakes" checked><label for="layer-lakes">Lakes</label></div>
            <div class="layer-item"><input type="checkbox" id="layer-seas" checked><label for="layer-seas">Sea Names</label></div>
            <div class="layer-item"><input type="checkbox" id="layer-sailing"><label for="layer-sailing">Sailing Routes</label></div>
          </div>
        </div>
      </div>
    `;
    document.body.appendChild(panel);
    console.log('[LayerPanel] Panel appended to body, checking visibility...');
    console.log('[LayerPanel] Panel element:', panel);
    console.log('[LayerPanel] Panel computed style display:', window.getComputedStyle(panel).display);
    console.log('[LayerPanel] Panel computed style visibility:', window.getComputedStyle(panel).visibility);
    console.log('[LayerPanel] Panel computed style z-index:', window.getComputedStyle(panel).zIndex);
    
    // Base map switching
    panel.querySelectorAll('input[name="basemap"]').forEach(radio=>{
      radio.addEventListener('change',function(){
        console.log('[LayerPanel] Base map changed to:', this.value);
        Object.values(baseMaps).forEach(l=>map.removeLayer(l));
        baseMaps[this.value].addTo(map);
        currentBaseMap=this.value;
      });
    });
    
    // Overlay toggles - standard layers
    const layerMap={
      'layer-travel':travelLineAndTime,
      'layer-roads':romanRoads,
      'layer-sealanes':seaLanes,
      'layer-bridges':ancientBridges,
      'layer-aqueducts':ancientAqueducts,
      'layer-famous-cities':famousCities,
      'layer-major-cities':majorCities,
      'layer-all-cities':ancientPlaces,
      'layer-forts':ancientFortifications,
      'layer-provinces':romanProvinces,
      'layer-borders':countryBorders,
      'layer-rivers':ancientRivers,
      'layer-lakes':ancientLakes,
      'layer-seas':ancientSeas,
      'layer-sailing':sailingRoutes
    };
    
    // Lazy-load function map
    const lazyLoadMap={
      'layer-roads':loadRomanRoads,
      'layer-sealanes':loadSeaLanes,
      'layer-bridges':loadAncientBridges,
      'layer-aqueducts':loadAncientAqueducts,
      'layer-famous-cities':loadFamousCities,
      'layer-major-cities':loadMajorCities,
      'layer-all-cities':loadAncientPlaces,
      'layer-forts':loadAncientFortifications,
      'layer-provinces':loadProvinces,
      'layer-rivers':loadAncientRivers,
      'layer-lakes':loadAncientLakes,
      'layer-seas':loadAncientSeas,
      'layer-sailing':loadSailingRoutes
    };
    
    Object.entries(layerMap).forEach(([id,layer])=>{
      const checkbox=panel.querySelector(`#${id}`);
      if(checkbox){
        checkbox.addEventListener('change',function(){
          console.log('[LayerToggle] Checkbox changed:', id, 'checked:', this.checked);
          if(this.checked){
            layer.addTo(map);
            // Fire event which triggers lazy-load and travel time display
            map.fire('overlayadd',{layer});
          }else{
            map.removeLayer(layer);
            map.fire('overlayremove',{layer});
          }
        });
      }
    });
    
    // Apply default layers (checked by default)
    const defaultLayers=['layer-travel','layer-famous-cities','layer-rivers','layer-lakes','layer-seas'];
    console.log('[LayerPanel] Applying default layers:', defaultLayers);
    defaultLayers.forEach(id=>{
      const checkbox=panel.querySelector(`#${id}`);
      if(checkbox&&checkbox.checked){
        const layer=layerMap[id];
        if(layer){
          console.log('[LayerPanel] Adding default layer:', id);
          layer.addTo(map);
          // Fire event which triggers lazy-load and travel time display
          map.fire('overlayadd',{layer});
        }
      }
    });
    
    console.log('[LayerPanel] Panel setup complete');
    return panel;
  }
  
  const layerPanelRef = buildLayerPanel();
  console.log('[LayerPanel] buildLayerPanel returned:', layerPanelRef);

  // Default data using new combined format
  const defaultChronoData='Antioch,Turkey~Antioch%0A47-48 AD: Antioch, Syria%0A2025 AD: Antakya, Turkey%0A%0AAntioch served as the primary mission base for Paul\'s ministry to the Gentiles and was where believers were first called Christians|Philippi,Greece~Philippi%0A49-50 AD: Philippi, Macedonia%0A2025 AD: Filippoi, Greece%0A%0APhilippi was the first European city where Paul established a Christian congregation during his second missionary journey|Ephesus,Turkey~Ephesus%0A52-54 AD: Ephesus, Asia Minor%0A2025 AD: Selçuk, Turkey%0A%0APaul ministered in Ephesus for approximately three years during his third missionary journey|Rome,Italy~Rome%0A62 AD: Rome, Capitol of the Roman Empire%0A2025 AD: Rome, Italy%0A%0APaul was held under house arrest in Rome from approximately AD 60 to 62';
  const defaultRefData='Jerusalem,Israel~Jerusalem%0A33 AD: Jerusalem, Judea%0A2025 AD: Jerusalem, Israel%0A%0AThe Church\'s birthplace and site of Pentecost';
  
  // Parse function for new combined format (Location~Label pairs)
  function parseLocationsAndLabels(paramStr){
    const results={locations:[],labels:[]};
    if(!paramStr)return results;
    const entries=paramStr.split('|').filter(Boolean);
    for(const entry of entries){
      const parts=entry.split('~');
      const location=parts[0]?.trim()||'';
      let label=parts[1]?.trim()||'';
      // If label is missing, empty, or explicitly "TBD", use the TBD placeholder
      if(!label||label===''||label==='TBD'){
        label=`TBD%0ATBD: Location information not provided%0A2025 AD: Unknown%0A%0APlease provide complete location details.`;
      }
      results.locations.push(location);
      results.labels.push(label);
    }
    return results;
  }
  
  // Parse URL parameters (chronoLocationsAndLabels and referenceLocationsAndLabels)
  const chronoParam=qs('chronoLocationsAndLabels');
  const refParam=qs('referenceLocationsAndLabels');
  
  // Parse chronological locations - only use defaults when NO URL params at all
  const chronoData=parseLocationsAndLabels(hasAnyParams?chronoParam:defaultChronoData);
  const chronoPoints=chronoData.locations;
  const chronoLabels=chronoData.labels;
  
  // Parse reference locations - only use defaults when NO URL params at all
  const refData=parseLocationsAndLabels(hasAnyParams?refParam:defaultRefData);
  const refPoints=refData.locations;
  const refLabels=refData.labels;

  const allMarkers=[];
  const chronoCoords=[];
  const chronoNames=[];
  
  const totalLocations=chronoPoints.length+refPoints.length;
  let processedCount=0;
  
  // Process chronological locations (blue markers)
  updateLoading('Loading locations...',`Processing chronological locations (0/${chronoPoints.length})`);
  for(let i=0;i<chronoPoints.length;i++){
    const q=chronoPoints[i].trim();
    if(!q)continue;
    
    updateLoading('Loading locations...',`Geocoding: ${q} (${processedCount+1}/${totalLocations})`);
    
    let coord=null;
    const m=q.match(/^(.*)@(-?\d+(?:\.\d+)?),(-?\d+(?:\.\d+)?)$/);
    if(m){coord={lat:parseFloat(m[2]),lon:parseFloat(m[3])};}
    else{coord=await geocode(q);}
    if(!coord)continue;
    chronoCoords.push({lat:coord.lat,lon:coord.lon});
    const labelEncoded=chronoLabels[i]||q;
    const label=labelEncoded.replace(/%0A/gi,'\n');
    const lines=label.split('\n');
    const locationName=lines[0]||q;
    chronoNames.push(locationName);
    const html=lines.map(l=>'<span class="popup-line">'+l+'</span>').join('');
    
    const mk=L.marker([coord.lat,coord.lon],{icon:blueIcon,pane:'journeyPane'})
      .addTo(map)
      .bindTooltip(locationName,{permanent:true,direction:'top',className:'marker-label',pane:'journeyLabelPane'})
      .on('click',()=>openDrawer(html));
    
    allMarkers.push(mk);
    processedCount++;
  }
  
  // Process reference locations (red markers)
  updateLoading('Loading locations...',`Processing reference locations (${processedCount}/${totalLocations})`);
  for(let i=0;i<refPoints.length;i++){
    const q=refPoints[i].trim();
    if(!q)continue;
    
    updateLoading('Loading locations...',`Geocoding: ${q} (${processedCount+1}/${totalLocations})`);
    
    let coord=null;
    const m=q.match(/^(.*)@(-?\d+(?:\.\d+)?),(-?\d+(?:\.\d+)?)$/);
    if(m){coord={lat:parseFloat(m[2]),lon:parseFloat(m[3])};}
    else{coord=await geocode(q);}
    if(!coord)continue;
    const labelEncoded=refLabels[i]||q;
    const label=labelEncoded.replace(/%0A/gi,'\n');
    const lines=label.split('\n');
    const locationName=lines[0]||q;
    const html=lines.map(l=>'<span class="popup-line">'+l+'</span>').join('');
    
    const mk=L.marker([coord.lat,coord.lon],{icon:redIcon,pane:'journeyPane'})
      .addTo(map)
      .bindTooltip(locationName,{permanent:true,direction:'top',className:'marker-label-reference',pane:'journeyLabelPane'})
      .on('click',()=>openDrawer(html));
    
    allMarkers.push(mk);
    processedCount++;
  }
  
  // Purple color palette for different segments (accessible and high contrast)
  const purpleColors=['#9333ea','#7c3aed','#6d28d9','#5b21b6','#4c1d95'];
  
  // Helper function to calculate point along a path at given distance
  function getPointAtDistance(latlngs,targetDist){
    let accumulated=0;
    for(let i=0;i<latlngs.length-1;i++){
      const p1=latlngs[i];
      const p2=latlngs[i+1];
      const segDist=map.distance(p1,p2);
      if(accumulated+segDist>=targetDist){
        const ratio=(targetDist-accumulated)/segDist;
        const lat=p1[0]+(p2[0]-p1[0])*ratio;
        const lng=p1[1]+(p2[1]-p1[1])*ratio;
        const bearing=Math.atan2(p2[1]-p1[1],p2[0]-p1[0])*180/Math.PI;
        return{lat,lng,bearing};
      }
      accumulated+=segDist;
    }
    return null;
  }
  
  // Route mode state - shared between initial calculation and UI updates
  let currentRouteMode='land'; // 'land' or 'water'
  const routeCache={land:[],water:[]}; // Cache routes for both modes
  
  // Draw travel paths between consecutive chronological locations with different colors
  // Now uses itiner-e graph-based routing instead of OSRM
  updateLoading('Calculating travel routes...',`Preparing ${chronoCoords.length-1} route segments`);
  let totalDistance=0;
  const legDistances=[];
  const legColors=[];
  const legRouteInfo=[]; // Store route info for each leg (for UI updates)
  
  for(let i=0;i<chronoCoords.length-1;i++){
    updateLoading('Calculating travel routes...',`Route ${i+1} of ${chronoCoords.length-1}: ${chronoNames[i]} → ${chronoNames[i+1]}`);
    
    // Calculate both land-only and mixed routes for this leg (with OSRM fallback)
    const landRoute=await getRouteWithFallback(chronoCoords[i],chronoCoords[i+1],false); // Land only
    const mixedRoute=await getRouteWithFallback(chronoCoords[i],chronoCoords[i+1],true);  // Land + sea
    
    routeCache.land.push(landRoute);
    routeCache.water.push(mixedRoute);
    
    // Use current route mode for initial display
    const route=currentRouteMode==='water'?mixedRoute:landRoute;
    const segmentColor=purpleColors[i%purpleColors.length];
    legColors.push(segmentColor);
    
    if(route&&route.geometry){
      const latlngs=route.geometry.coordinates.map(c=>[c[1],c[0]]);
      const isFallback=route.isFallback||false;
      
      // Draw main path - dashed for fallback (modern roads), solid for Roman roads
      if(isFallback){
        // Dashed line for OSRM fallback (modern road approximation)
        L.polyline(latlngs,{color:'#ffffff',weight:5,opacity:0.9,dashArray:'10,8'}).addTo(travelLineAndTime);
        L.polyline(latlngs,{color:segmentColor,weight:3,opacity:0.95,dashArray:'10,8'}).addTo(travelLineAndTime);
      }else{
        // Solid line for Roman roads
        L.polyline(latlngs,{color:'#ffffff',weight:5,opacity:0.9}).addTo(travelLineAndTime);
        L.polyline(latlngs,{color:segmentColor,weight:3,opacity:0.95}).addTo(travelLineAndTime);
      }
      
      // Calculate total path length
      let pathLength=0;
      for(let j=0;j<latlngs.length-1;j++){
        pathLength+=map.distance(latlngs[j],latlngs[j+1]);
      }
      
      // Add numbered arrow markers at regular intervals (25% fewer markers)
      const segmentNumber=i+1;
      const arrowInterval=Math.min(150000,pathLength/4);
      const numArrows=Math.max(2,Math.floor((pathLength/arrowInterval)*0.75));
      
      for(let a=1;a<=numArrows;a++){
        const distAlongPath=(pathLength/(numArrows+1))*a;
        const point=getPointAtDistance(latlngs,distAlongPath);
        if(point){
          const arrowHtml='<div style="width:18px;height:18px;background:#ffffff;border-radius:50%;display:flex;align-items:center;justify-content:center;font-weight:700;font-size:10px;color:#000;box-shadow:0 2px 6px rgba(0,0,0,0.3),0 0 0 2px '+segmentColor+'">'+segmentNumber+'</div>';
          const arrow=L.marker([point.lat,point.lng],{
            icon:L.divIcon({
              className:'arrow-marker',
              html:arrowHtml,
              iconSize:[18,18],
              iconAnchor:[9,9]
            }),
            interactive:false
          }).addTo(travelLineAndTime);
        }
      }
      
      // Store route info for travel time calculations (with actual land/sea breakdown)
      legRouteInfo.push({
        landDist:landRoute?landRoute.distance:0,
        mixedDist:mixedRoute?mixedRoute.distance:0,
        hasSea:mixedRoute?mixedRoute.hasSeaSegments:false,
        landRoute,mixedRoute,
        mixedLandKm:mixedRoute?(mixedRoute.landDistKm||0):0,
        mixedSeaKm:mixedRoute?(mixedRoute.seaDistKm||0):0,
        isFallback:route.isFallback||false
      });
      
      totalDistance+=route.distance;
      legDistances.push(route.distance);
    }else{
      legDistances.push(0);
      legRouteInfo.push({landDist:0,mixedDist:0,hasSea:false,landRoute:null,mixedRoute:null});
    }
  }
  
  if(allMarkers.length){
    const g=new L.featureGroup(allMarkers);
    map.fitBounds(g.getBounds().pad(0.18));
    
    // Create travel time display with transport mode support
    if(totalDistance>0){
      // Transport speeds in km/h (from itiner-e research)
      const transportSpeeds={walking:4,pack:4.5,horse:6,oxcart:2};
      const SAILING_SPEED_KMH=7.4; // 4 knots in km/h
      let currentTransport='walking';
      
      // Calculate travel time based on distance and transport mode
      const formatTime=(distanceMeters,speedKmH)=>{
        const distKm=distanceMeters/1000;
        const hoursPerDay=8; // Assume 8 hours of travel per day
        const totalHours=distKm/speedKmH;
        const totalDays=Math.ceil(totalHours/hoursPerDay);
        const weeks=Math.floor(totalDays/7);
        const days=totalDays%7;
        let timeStr='';
        if(weeks>0)timeStr+=`${weeks} week${weeks>1?'s':''} `;
        if(days>0||weeks===0)timeStr+=`${days} day${days!==1?'s':''}`;
        return {timeStr:timeStr.trim(),distKm:distKm.toFixed(0),totalDays,totalHours:Math.round(totalHours)};
      };
      
      // Create travel time display element (hidden by default)
      const travelTimeDiv=document.createElement('div');
      travelTimeDiv.className='distance-info';
      travelTimeDiv.style.display='none';
      document.body.appendChild(travelTimeDiv);
      
      // Function to redraw routes based on current mode
      function redrawRoutes(){
        // Clear existing travel lines AND numbered markers
        travelLineAndTime.eachLayer(layer=>{
          if(layer instanceof L.Polyline||layer instanceof L.Circle||layer instanceof L.Marker){
            travelLineAndTime.removeLayer(layer);
          }
        });
        
        // Redraw routes for current mode with numbered badges
        for(let i=0;i<legRouteInfo.length;i++){
          const info=legRouteInfo[i];
          const route=currentRouteMode==='water'?info.mixedRoute:info.landRoute;
          const segmentColor=legColors[i];
          const isFallback=route&&route.isFallback;
          
          if(route&&route.geometry){
            const latlngs=route.geometry.coordinates.map(c=>[c[1],c[0]]);
            
            // Draw main path - dashed for fallback (modern roads), solid for Roman roads
            if(isFallback){
              L.polyline(latlngs,{color:'#ffffff',weight:5,opacity:0.9,dashArray:'10,8'}).addTo(travelLineAndTime);
              L.polyline(latlngs,{color:segmentColor,weight:3,opacity:0.95,dashArray:'10,8'}).addTo(travelLineAndTime);
            }else{
              L.polyline(latlngs,{color:'#ffffff',weight:5,opacity:0.9}).addTo(travelLineAndTime);
              L.polyline(latlngs,{color:segmentColor,weight:3,opacity:0.95}).addTo(travelLineAndTime);
            }
            
            // Calculate path length for badge placement
            let pathLength=0;
            for(let j=0;j<latlngs.length-1;j++){
              pathLength+=map.distance(latlngs[j],latlngs[j+1]);
            }
            
            // Add numbered badges at regular intervals
            const segmentNumber=i+1;
            const arrowInterval=Math.min(150000,pathLength/4);
            const numArrows=Math.max(2,Math.floor((pathLength/arrowInterval)*0.75));
            
            for(let a=1;a<=numArrows;a++){
              const distAlongPath=(pathLength/(numArrows+1))*a;
              const point=getPointAtDistance(latlngs,distAlongPath);
              if(point){
                const arrowHtml='<div style="width:18px;height:18px;background:#ffffff;border-radius:50%;display:flex;align-items:center;justify-content:center;font-weight:700;font-size:10px;color:#000;box-shadow:0 2px 6px rgba(0,0,0,0.3),0 0 0 2px '+segmentColor+'">'+segmentNumber+'</div>';
                L.marker([point.lat,point.lng],{
                  icon:L.divIcon({
                    className:'arrow-marker',
                    html:arrowHtml,
                    iconSize:[18,18],
                    iconAnchor:[9,9]
                  }),
                  interactive:false
                }).addTo(travelLineAndTime);
              }
            }
          }
        }
      }
      
      // Update travel time display based on current transport mode and route mode
      function updateTravelTimeDisplay(){
        const landSpeed=transportSpeeds[currentTransport];
        
        // Calculate totals based on route mode using new legRouteInfo
        let totalLandDist=0,totalWaterDist=0,totalLandHours=0,totalWaterHours=0;
        const legDetails=[];
        
        for(let i=0;i<legRouteInfo.length;i++){
          const info=legRouteInfo[i];
          
          if(currentRouteMode==='water'){
            // Use mixed route with actual land/sea breakdown from graph routing
            const legLandKm=info.mixedLandKm||0;
            const legSeaKm=info.mixedSeaKm||0;
            const legDist=info.mixedDist||0;
            
            // Use actual edge-type breakdown
            totalLandDist+=legLandKm*1000;
            totalWaterDist+=legSeaKm*1000;
            totalLandHours+=legLandKm/landSpeed;
            totalWaterHours+=legSeaKm/SAILING_SPEED_KMH;
            legDetails.push({type:info.hasSea?'mixed':'land',dist:legDist,speed:landSpeed,name:`${chronoNames[i]} → ${chronoNames[i+1]}`,hasSea:info.hasSea,landKm:legLandKm,seaKm:legSeaKm});
          }else{
            // Land only mode - use land route distance
            const legDist=info.landDist||0;
            totalLandDist+=legDist;
            totalLandHours+=legDist/1000/landSpeed;
            legDetails.push({type:'land',dist:legDist,speed:landSpeed,name:`${chronoNames[i]} → ${chronoNames[i+1]}`,hasSea:false,landKm:legDist/1000,seaKm:0});
          }
        }
        
        const hoursPerDay=8;
        const totalHours=totalLandHours+totalWaterHours;
        const totalDays=Math.ceil(totalHours/hoursPerDay);
        const totalDistKm=((totalLandDist+totalWaterDist)/1000).toFixed(0);
        const weeks=Math.floor(totalDays/7);
        const days=totalDays%7;
        let totalTimeStr='';
        if(weeks>0)totalTimeStr+=`${weeks} week${weeks>1?'s':''} `;
        if(days>0||weeks===0)totalTimeStr+=`${days} day${days!==1?'s':''}`;
        
        // Build legs display with type indicators
        let legsHtml='';
        for(let i=0;i<legDetails.length;i++){
          const leg=legDetails[i];
          const distKm=(leg.dist/1000).toFixed(0);
          const legHours=leg.dist/1000/leg.speed;
          const legDays=Math.ceil(legHours/hoursPerDay);
          const lWeeks=Math.floor(legDays/7);
          const lDays=legDays%7;
          let legTimeStr='';
          if(lWeeks>0)legTimeStr+=`${lWeeks}w `;
          if(lDays>0||lWeeks===0)legTimeStr+=`${lDays}d`;
          
          const segmentNum=i+1;
          const typeIcon=leg.hasSea?'<span style="color:#0891b2" title="Includes sea route">⚓</span>':'';
          const segmentLabel=`<span style="display:inline-block;width:18px;height:18px;background:#ffffff;border-radius:50%;text-align:center;line-height:18px;font-size:10px;font-weight:700;border:2px solid ${legColors[i]||'#6b7280'};margin-right:8px;vertical-align:middle;">${segmentNum}</span>`;
          legsHtml+=`<div>${segmentLabel}${typeIcon}${leg.name}: <span style="color:#6b7280;">${legTimeStr} (${distKm} km)</span></div>`;
        }
        
        const modeLabels={walking:'Walking',pack:'Pack Animal',horse:'Horse Courier',oxcart:'Ox Cart'};
        const modeSpeeds={walking:'4',pack:'4.5',horse:'6',oxcart:'2'};
        
        // Build route mode selector (Land Only / Use Water)
        let routeModeHtml='<div class="route-mode-inline"><div class="route-mode-inline-title">Route Type:</div>';
        routeModeHtml+=`<button class="route-btn ${currentRouteMode==='land'?'active':''}" data-route="land"><span class="icon">🚶</span>Land Only</button>`;
        routeModeHtml+=`<button class="route-btn ${currentRouteMode==='water'?'active':''}" data-route="water"><span class="icon">⛵</span>Use Water</button>`;
        routeModeHtml+='</div>';
        
        // Build inline transport mode selector
        let transportHtml='<div class="transport-inline"><div class="transport-inline-title">Land Transport:</div>';
        for(const [mode,label] of Object.entries(modeLabels)){
          const isActive=mode===currentTransport?'active':'';
          transportHtml+=`<button class="transport-btn ${isActive}" data-mode="${mode}">${label} <span class="speed">(${modeSpeeds[mode]} km/h)</span></button>`;
        }
        transportHtml+='</div>';
        
        // Water breakdown info
        let waterBreakdownHtml='';
        if(currentRouteMode==='water'&&totalWaterDist>0){
          const waterKm=(totalWaterDist/1000).toFixed(0);
          const landKm=(totalLandDist/1000).toFixed(0);
          const waterDays=Math.ceil(totalWaterHours/hoursPerDay);
          const landDays=Math.ceil(totalLandHours/hoursPerDay);
          waterBreakdownHtml=`<div class="water-breakdown">⚓ Sea: ${waterKm} km (${waterDays}d @ 4 knots) | 🚶 Land: ${landKm} km (${landDays}d)</div>`;
        }
        
        // Route legend showing line styles
        const hasWaterCrossings=currentRouteMode==='water'&&legRouteInfo.some(info=>info.hasSea);
        const hasFallbackRoutes=legRouteInfo.some(info=>info.isFallback);
        let legendHtml='';
        if(hasWaterCrossings||hasFallbackRoutes){
          let notes=[];
          if(hasWaterCrossings){
            notes.push('Route uses itiner-e Roman roads and ancient sea lanes for mixed land/water travel.');
          }
          if(hasFallbackRoutes){
            notes.push('<span style="border-bottom:2px dashed #9333ea">Dashed lines</span> indicate routes outside the Roman road network (using modern road approximation).');
          }
          legendHtml=`<div style="margin-top:8px;padding-top:8px;border-top:1px solid #e5e7eb;font-size:11px;color:#6b7280">
            <strong>Note:</strong> ${notes.join(' ')}
          </div>`;
        }
        
        const headerLabel=currentRouteMode==='water'?`${modeLabels[currentTransport]} + Sailing`:`${modeLabels[currentTransport]}`;
        
        travelTimeDiv.innerHTML=`
          <div class="distance-info-header">
            <div><strong>Travel Time (${headerLabel}):</strong> ${totalTimeStr.trim()} <span style="font-size:12px;color:#6b7280">(${totalDistKm} km)</span></div>
            <button class="distance-info-toggle" onclick="this.parentElement.nextElementSibling.classList.toggle('expanded');this.textContent=this.textContent==='▼'?'▲':'▼'">▼</button>
          </div>
          <div class="distance-info-details">${legsHtml}${waterBreakdownHtml}${legendHtml}</div>
          ${routeModeHtml}
          ${transportHtml}
        `;
        
        // Attach click handlers to route mode buttons
        travelTimeDiv.querySelectorAll('.route-btn').forEach(btn=>{
          btn.addEventListener('click',function(){
            currentRouteMode=this.dataset.route;
            redrawRoutes();
            updateTravelTimeDisplay();
          });
        });
        
        // Attach click handlers to transport buttons
        travelTimeDiv.querySelectorAll('.transport-btn').forEach(btn=>{
          btn.addEventListener('click',function(){
            currentTransport=this.dataset.mode;
            updateTravelTimeDisplay();
          });
        });
      }
      
      // Initial display
      updateTravelTimeDisplay();
      
      // Show/hide travel time display based on layer toggle
      map.on('overlayadd',function(e){
        if(e.layer===travelLineAndTime){
          travelTimeDiv.style.display='block';
        }
      });
      map.on('overlayremove',function(e){
        if(e.layer===travelLineAndTime){
          travelTimeDiv.style.display='none';
        }
      });
      
      // Show travel time if layer was already added during page load
      if(map.hasLayer(travelLineAndTime)){
        travelTimeDiv.style.display='block';
      }
    }
  }else{map.setView([37.8,20],5);}
  
  // All routes calculated and map ready - hide loading overlay
  console.log('[Init] All routes calculated, map ready');
  updateLoading('Map ready!','');
  setTimeout(hideLoading,300);
})();
</script>
</body>
</html>
