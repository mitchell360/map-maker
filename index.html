<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>URL Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="">
  <style>
    html,body,#map{height:100%;margin:0;padding:0}
    
    /* Content styling for drawer - elegant serif fonts matching old popups */
    .drawer-content{font-family:Georgia,Cambria,"Times New Roman",serif}
    .popup-line{display:block;white-space:pre-wrap;margin-bottom:14px;line-height:1.6}
    .popup-line:first-child{font-family:Georgia,Cambria,"Times New Roman",serif;font-weight:700;font-size:32px;color:#0b5394;letter-spacing:0;margin-bottom:16px;line-height:1.2}
    .popup-line:nth-child(2),.popup-line:nth-child(3){color:#5f6368;font-size:15px;margin-bottom:10px;line-height:1.5}
    .popup-line:nth-child(n+4){color:#202124;font-size:16px;margin-top:18px;margin-bottom:12px;line-height:1.6}
    .popup-line:last-child{margin-bottom:0}
    
    /* Unified drawer - works on all devices */
    .drawer-backdrop{position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.5);z-index:2000;display:none;opacity:0;transition:opacity 0.3s ease;pointer-events:none}
    .drawer-backdrop.active{display:block;opacity:1;pointer-events:auto}
    .drawer{position:fixed;background:#fff;box-shadow:0 -4px 20px rgba(0,0,0,0.3);z-index:2001;transform:translateY(100%);transition:transform 0.3s cubic-bezier(0.4,0,0.2,1);display:flex;flex-direction:column;pointer-events:none}
    .drawer.active{transform:translateY(0);pointer-events:auto}
    .drawer-handle{width:40px;height:4px;background:#cbd5e1;border-radius:2px;margin:12px auto 8px;cursor:grab;flex-shrink:0}
    .drawer-content{overflow-y:auto;padding:0 20px 20px;flex:1}
    
    /* Mobile: bottom drawer */
    @media (max-width: 768px) {
      .drawer{bottom:0;left:0;right:0;border-radius:20px 20px 0 0;max-height:70vh}
    }
    
    /* Desktop: centered modal */
    @media (min-width: 769px) {
      .drawer{top:50%;left:50%;right:auto;bottom:auto;transform:translate(-50%,-50%) scale(0.9);border-radius:12px;max-width:600px;width:90%;max-height:80vh;opacity:0;visibility:hidden}
      .drawer.active{transform:translate(-50%,-50%) scale(1);opacity:1;visibility:visible}
      .drawer-handle{display:none}
      .popup-line:first-child{font-size:48px}
      .popup-line:nth-child(2),.popup-line:nth-child(3){font-size:17px}
      .popup-line:nth-child(n+4){font-size:18px}
    }
    
    /* Travel time display - responsive */
    .distance-info{position:absolute;z-index:1000;background:#fff;padding:10px 16px;border-radius:6px;font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;box-shadow:0 2px 12px rgba(0,0,0,.2);border:2px solid #0369a1}
    .distance-info-header{display:flex;justify-content:space-between;align-items:center;gap:8px}
    .distance-info-toggle{background:none;border:none;color:#0369a1;font-size:18px;cursor:pointer;padding:0;line-height:1;display:none}
    .distance-info-details{margin-top:8px}
    
    /* Desktop positioning */
    @media (min-width: 769px) {
      .distance-info{bottom:12px;left:50%;transform:translateX(-50%);max-width:600px}
    }
    
    /* Mobile positioning and collapsible */
    @media (max-width: 768px) {
      .distance-info{bottom:12px;left:12px;right:12px;max-width:none}
      .distance-info-toggle{display:inline-block}
      .distance-info-details{display:none}
      .distance-info-details.expanded{display:block}
      .distance-info-details > div{font-size:12px;line-height:1.5}
    }
    
    /* Instructions link - responsive */
    /* Instructions button - always shows as ? in upper right on all devices */
    .instructions-link{position:absolute;top:60px;right:12px;z-index:400;background:#fff;border-radius:50%;box-shadow:0 2px 12px rgba(0,0,0,.2);border:2px solid #0369a1;padding:0;width:36px;height:36px;display:flex;align-items:center;justify-content:center}
    .instructions-link a{color:#0369a1;text-decoration:none;font-weight:700;font-size:20px;display:flex;width:100%;height:100%;align-items:center;justify-content:center}
    .instructions-link a:hover{background:#f0f9ff;border-radius:50%}
    
    /* Tooltip styles */
    .leaflet-tooltip.marker-label{
      background:#0369a1!important;
      color:#ffffff!important;
      border:none!important;
      box-shadow:0 2px 8px rgba(0,0,0,.3)!important;
      font-weight:700!important;
      font-size:14px!important;
      padding:4px 8px!important;
      border-radius:4px!important;
    }
    .leaflet-tooltip.marker-label::before{
      border-top-color:#0369a1!important;
    }
    .leaflet-tooltip.marker-label-reference{
      background:#dc2626!important;
      color:#ffffff!important;
      border:none!important;
      box-shadow:0 2px 8px rgba(0,0,0,.3)!important;
      font-weight:700!important;
      font-size:14px!important;
      padding:4px 8px!important;
      border-radius:4px!important;
    }
    .leaflet-tooltip.marker-label-reference::before{
      border-top-color:#dc2626!important;
    }
    
    /* Numbered arrow markers for travel direction */
    .arrow-marker{
      background:transparent!important;
      border:none!important;
      box-shadow:none!important;
    }
    .arrow-marker div{
      font-family:system-ui,-apple-system,sans-serif;
    }
    
    /* Map title */
    .map-title{position:absolute;top:12px;left:50%;transform:translateX(-50%);z-index:3100;background:rgba(255,255,255,0.95);padding:12px 24px;border-radius:8px;box-shadow:0 2px 12px rgba(0,0,0,.2);font-family:Georgia,Cambria,"Times New Roman",serif;font-size:24px;font-weight:700;color:#0b5394;text-align:center;max-width:calc(100% - 100px);pointer-events:none}
    @media (max-width: 768px) {
      .map-title{font-size:18px;padding:8px 16px;top:8px;max-width:calc(100% - 80px)}
    }
    
    /* Loading overlay */
    .loading-overlay{position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(255,255,255,0.95);z-index:3000;display:flex;flex-direction:column;align-items:center;justify-content:center;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
    .loading-spinner{width:48px;height:48px;border:4px solid #e5e7eb;border-top-color:#0369a1;border-radius:50%;animation:spin 0.8s linear infinite;margin-bottom:20px}
    @keyframes spin{to{transform:rotate(360deg)}}
    .loading-text{font-size:18px;color:#374151;font-weight:500;margin-bottom:8px}
    .loading-detail{font-size:14px;color:#6b7280}
    
    /* Transport mode selector */
    /* Transport selector - inline in travel time box */
    .transport-inline{display:flex;flex-wrap:wrap;gap:4px;margin-top:8px;padding-top:8px;border-top:1px solid #e5e7eb}
    .transport-inline-title{width:100%;font-size:11px;color:#6b7280;margin-bottom:2px}
    .transport-btn{padding:4px 8px;font-size:11px;border:1px solid #d1d5db;border-radius:4px;background:#fff;cursor:pointer;transition:all 0.15s;white-space:nowrap}
    .transport-btn:hover{border-color:#0369a1;background:#f0f9ff}
    .transport-btn.active{background:#0369a1;color:#fff;border-color:#0369a1}
    .transport-btn .speed{font-size:10px;opacity:0.8}
    
    /* Route mode selector (Land Only / Use Water) */
    .route-mode-inline{display:flex;flex-wrap:wrap;gap:4px;margin-top:8px;padding-top:8px;border-top:1px solid #e5e7eb}
    .route-mode-inline-title{width:100%;font-size:11px;color:#6b7280;margin-bottom:2px}
    .route-btn{padding:4px 10px;font-size:11px;border:1px solid #d1d5db;border-radius:4px;background:#fff;cursor:pointer;transition:all 0.15s;white-space:nowrap}
    .route-btn:hover{border-color:#0891b2;background:#ecfeff}
    .route-btn.active{background:#0891b2;color:#fff;border-color:#0891b2}
    .route-btn .icon{margin-right:4px}
    .water-breakdown{margin-top:6px;padding:6px 8px;background:#f0fdfa;border-radius:4px;font-size:11px;color:#0f766e}
  </style>
</head>
<body>
<!-- Loading overlay -->
<div class="loading-overlay" id="loadingOverlay">
  <div class="loading-spinner"></div>
  <div class="loading-text" id="loadingText">Loading map...</div>
  <div class="loading-detail" id="loadingDetail"></div>
</div>

<div id="map"></div>

<!-- Mobile drawer -->
<div class="drawer-backdrop" id="drawerBackdrop"></div>
<div class="drawer" id="drawer">
  <div class="drawer-handle" id="drawerHandle"></div>
  <div class="drawer-content" id="drawerContent"></div>
</div>

<!-- Instructions link - always shows as ? button -->
<div class="instructions-link">
  <a href="https://mitchell360.com/map-maker/llm.md" target="_blank" title="Instructions for using this Map Maker">?</a>
</div>


<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
  integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
<script>
// Cache-busting: Auto-add version parameter to force fresh loads in Replit preview
(function(){
  const url=new URL(window.location.href);
  if(!url.searchParams.has('_cb')){
    url.searchParams.set('_cb',Date.now());
    window.location.replace(url.toString());
  }
})();

// Utility functions
function qs(name){const u=new URL(location.href);return u.searchParams.get(name);}

// Drawer functionality
const drawer=document.getElementById('drawer');
const drawerBackdrop=document.getElementById('drawerBackdrop');
const drawerContent=document.getElementById('drawerContent');
const drawerHandle=document.getElementById('drawerHandle');

let drawerStartY=0;
let drawerCurrentY=0;
let isDragging=false;

function openDrawer(html){
  drawerContent.innerHTML=html;
  drawer.classList.add('active');
  drawerBackdrop.classList.add('active');
}

function closeDrawer(){
  drawer.classList.remove('active');
  drawerBackdrop.classList.remove('active');
  drawer.style.transform='';
}

// Touch gestures for drawer
drawerHandle.addEventListener('touchstart',e=>{
  isDragging=true;
  drawerStartY=e.touches[0].clientY;
  drawer.style.transition='none';
});

drawerHandle.addEventListener('touchmove',e=>{
  if(!isDragging)return;
  drawerCurrentY=e.touches[0].clientY-drawerStartY;
  if(drawerCurrentY>0){
    drawer.style.transform=`translateY(${drawerCurrentY}px)`;
  }
});

drawerHandle.addEventListener('touchend',e=>{
  if(!isDragging)return;
  isDragging=false;
  drawer.style.transition='';
  if(drawerCurrentY>100){
    closeDrawer();
  }else{
    drawer.style.transform='translateY(0)';
  }
  drawerCurrentY=0;
});

// Click backdrop to close
drawerBackdrop.addEventListener('click',closeDrawer);

// Geocoding
async function geocode(q){
  const url='https://nominatim.openstreetmap.org/search?format=json&limit=1&q='+encodeURIComponent(q);
  const r=await fetch(url,{headers:{'Accept-Language':'en','User-Agent':'URL-Map/1.0'}});
  if(!r.ok)return null;
  const j=await r.json();
  if(j&&j.length)return{lat:parseFloat(j[0].lat),lon:parseFloat(j[0].lon),display:j[0].display_name};
  return null;
}

// Walking routes
async function getWalkingRoute(start,end){
  const coords=`${start.lon},${start.lat};${end.lon},${end.lat}`;
  const url=`https://routing.openstreetmap.de/routed-foot/route/v1/foot/${coords}?overview=full&geometries=geojson`;
  try{
    const r=await fetch(url);
    const data=await r.json();
    if(data.code==='Ok'&&data.routes&&data.routes.length>0){
      return{
        distance:data.routes[0].distance,
        duration:data.routes[0].duration,
        geometry:data.routes[0].geometry
      };
    }
  }catch(e){console.error('Route error:',e);}
  return null;
}

// Loading indicator helpers
const loadingOverlay=document.getElementById('loadingOverlay');
const loadingText=document.getElementById('loadingText');
const loadingDetail=document.getElementById('loadingDetail');

function updateLoading(text,detail=''){
  loadingText.textContent=text;
  loadingDetail.textContent=detail;
}

function hideLoading(){
  loadingOverlay.style.display='none';
}

// Initialize map
(async function(){
  updateLoading('Initializing map...');
  
  const map=L.map('map',{zoomControl:true}).setView([20,0],2);
  const dare=L.tileLayer('https://dh.gu.se/tiles/imperium/{z}/{x}/{y}.png',{minZoom:4,maxZoom:11,attribution:'Â© <a href="https://dh.gu.se/dare/">Digital Atlas of the Roman Empire</a>'}).addTo(map);
  const positron=L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png',{maxZoom:19,attribution:'Â© OpenStreetMap Â© CartoDB'});
  const osm=L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:19,attribution:'Â© OpenStreetMap'});
  const baseLayers={'Ancient World':dare,'Modern (Clean)':positron,'Modern (Detailed)':osm};
  
  // Check if ANY URL parameters exist (excluding cache-buster)
  const urlParamsRaw=new URLSearchParams(window.location.search);
  urlParamsRaw.delete('_cb');
  const hasAnyParams=urlParamsRaw.toString().length>0;
  
  // Add title - only use default when NO URL parameters at all
  const titleParam=qs('title');
  const defaultTitle="Sample: Paul's Missionary Journeys";
  const displayTitle=hasAnyParams?(titleParam||''):defaultTitle;
  
  if(displayTitle){
    const titleDiv=document.createElement('div');
    titleDiv.className='map-title';
    titleDiv.textContent=displayTitle;
    document.body.appendChild(titleDiv);
  }
  
  // Custom marker icons
  const blueIcon=L.icon({iconUrl:'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-blue.png',shadowUrl:'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',iconSize:[25,41],iconAnchor:[12,41],popupAnchor:[1,-34],shadowSize:[41,41]});
  const redIcon=L.icon({iconUrl:'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',shadowUrl:'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',iconSize:[25,41],iconAnchor:[12,41],popupAnchor:[1,-34],shadowSize:[41,41]});
  
  // Create overlay layers
  const countryBorders=L.layerGroup();
  const travelLineAndTime=L.layerGroup();
  const romanRoads=L.layerGroup();
  const seaLanes=L.layerGroup();
  const sailingRoutes=L.layerGroup();
  
  // Add invisible placeholder so layer shows in control
  travelLineAndTime.addLayer(L.circle([0,0],{radius:1,opacity:0}));
  romanRoads.addLayer(L.circle([0,0],{radius:1,opacity:0}));
  seaLanes.addLayer(L.circle([0,0],{radius:1,opacity:0}));
  sailingRoutes.addLayer(L.circle([0,0],{radius:1,opacity:0}));
  
  // Load country borders from local file
  fetch('country_borders.geojson')
    .then(r=>r.json())
    .then(data=>{
      L.geoJSON(data,{
        style:{
          color:'#1f2937',
          weight:2.5,
          opacity:0.8,
          fillOpacity:0
        }
      }).addTo(countryBorders);
    })
    .catch(e=>console.error('Border load error:',e));
  
  // Load Roman roads from local file (downloaded from itiner-e.org)
  let romanRoadsLoaded=false;
  let seaLanesLoaded=false;
  let roadDataCache=null;
  
  function fetchRoadData(){
    if(roadDataCache)return Promise.resolve(roadDataCache);
    return fetch('roman_roads.ndjson')
      .then(r=>r.text())
      .then(text=>{
        const lines=text.trim().split('\n');
        const features=[];
        for(const line of lines){
          try{
            const feature=JSON.parse(line);
            features.push(feature);
          }catch(e){}
        }
        roadDataCache=features;
        return features;
      });
  }
  
  function loadRomanRoads(){
    if(romanRoadsLoaded)return;
    romanRoadsLoaded=true;
    
    fetchRoadData().then(features=>{
        // Filter out Sea Lanes - only show land roads
        const landRoads=features.filter(f=>f.properties&&f.properties.type!=='Sea Lane'&&f.properties.type!=='River');
        
        // Style roads by type and certainty
        function getRoadStyle(props){
          const isMain=props.type==='Main Road';
          const certainty=props.segmentCertainty||'Conjectured';
          
          let color='#8B4513'; // Default brown for roman roads
          let weight=isMain?2.5:1.5;
          let opacity=0.8;
          let dashArray=null;
          
          if(certainty==='Certain'){
            color=isMain?'#8B4513':'#A0522D'; // Darker brown for certain roads
            opacity=0.9;
          }else if(certainty==='Conjectured'){
            color=isMain?'#CD853F':'#D2691E'; // Lighter brown for conjectured
            opacity=0.7;
          }else if(certainty==='Hypothetical'){
            color='#DEB887';
            opacity=0.5;
            dashArray='4,4';
          }
          
          return{color,weight,opacity,dashArray};
        }
        
        // Create GeoJSON layer for land roads only
        const roadsLayer=L.geoJSON({type:'FeatureCollection',features:landRoads},{
          style:f=>getRoadStyle(f.properties),
          onEachFeature:(f,layer)=>{
            const props=f.properties;
            const name=props.name||'Roman Road';
            const type=props.type||'Road';
            const certainty=props.segmentCertainty||'Unknown';
            const length=(props._lengthInKm||0).toFixed(2);
            const period=props.constructionPeriod||'Unknown period';
            layer.bindPopup(`<b>${name}</b><br>Type: ${type}<br>Certainty: ${certainty}<br>Length: ${length} km<br>Period: ${period}`);
          }
        });
        
        romanRoads.clearLayers();
        romanRoads.addLayer(roadsLayer);
        console.log(`Loaded ${landRoads.length} Roman road segments (land only)`);
      })
      .catch(e=>console.error('Roman roads load error:',e));
  }
  
  // Load sea lanes/sailing routes
  function loadSeaLanes(){
    if(seaLanesLoaded)return;
    seaLanesLoaded=true;
    
    fetchRoadData().then(features=>{
        // Filter to Sea Lanes and Rivers only
        const waterRoutes=features.filter(f=>f.properties&&(f.properties.type==='Sea Lane'||f.properties.type==='River'));
        
        // Create GeoJSON layer for sea routes with distinct styling
        const seaLayer=L.geoJSON({type:'FeatureCollection',features:waterRoutes},{
          style:f=>{
            const isRiver=f.properties.type==='River';
            return{
              color:isRiver?'#2563eb':'#0ea5e9', // Blue for rivers, cyan for sea lanes
              weight:isRiver?2:2.5,
              opacity:0.7,
              dashArray:isRiver?null:'6,4' // Dashed for sea lanes
            };
          },
          onEachFeature:(f,layer)=>{
            const props=f.properties;
            const name=props.name||'Sea Route';
            const type=props.type||'Route';
            const length=(props._lengthInKm||0).toFixed(2);
            layer.bindPopup(`<b>${name}</b><br>Type: ${type}<br>Length: ${length} km`);
          }
        });
        
        seaLanes.clearLayers();
        seaLanes.addLayer(seaLayer);
        console.log(`Loaded ${waterRoutes.length} sea lanes and river routes`);
      })
      .catch(e=>console.error('Sea lanes load error:',e));
  }
  
  // Load Mendeley sailing routes from JSON (ancient Mediterranean shipping network)
  let sailingRoutesLoaded=false;
  function loadSailingRoutes(){
    if(sailingRoutesLoaded)return;
    sailingRoutesLoaded=true;
    
    fetch('sailing_routes.json')
      .then(r=>r.json())
      .then(data=>{
        const ports=data.ports;
        const routes=data.routes;
        
        // Create port markers (small circles)
        const portMarkers=[];
        for(const [name,info] of Object.entries(ports)){
          const marker=L.circleMarker([info.lat,info.lon],{
            radius:5,
            fillColor:'#0ea5e9',
            color:'#0369a1',
            weight:2,
            opacity:1,
            fillOpacity:0.8
          });
          marker.bindPopup(`<b>${name}</b><br><span style="color:#6b7280">${info.modern}</span><br><span style="font-size:11px">Ancient Mediterranean Port</span>`);
          portMarkers.push(marker);
        }
        
        // Create route lines
        const routeLines=[];
        for(const route of routes){
          const fromPort=ports[route.from];
          const toPort=ports[route.to];
          if(fromPort&&toPort){
            const line=L.polyline([[fromPort.lat,fromPort.lon],[toPort.lat,toPort.lon]],{
              color:'#0ea5e9',
              weight:1.5,
              opacity:0.5,
              dashArray:'4,6'
            });
            line.bindPopup(`<b>${route.from} â†” ${route.to}</b><br><span style="font-size:11px;color:#6b7280">Ancient sailing route (Mendeley research data)</span>`);
            routeLines.push(line);
          }
        }
        
        sailingRoutes.clearLayers();
        routeLines.forEach(l=>sailingRoutes.addLayer(l));
        portMarkers.forEach(m=>sailingRoutes.addLayer(m));
        console.log(`Loaded ${Object.keys(ports).length} ancient ports and ${routes.length} sailing routes`);
      })
      .catch(e=>console.error('Sailing routes load error:',e));
  }
  
  // Load layers when overlay is added
  map.on('overlayadd',function(e){
    if(e.layer===romanRoads)loadRomanRoads();
    if(e.layer===seaLanes)loadSeaLanes();
    if(e.layer===sailingRoutes)loadSailingRoutes();
  });
  
  // Overlays are OFF by default but available in layer control
  const overlays={
    'Country Borders':countryBorders,
    'Roman Roads':romanRoads,
    'Sea Lanes (itiner-e)':seaLanes,
    'Sailing Routes (Mendeley)':sailingRoutes,
    'Travel Line and Time':travelLineAndTime
  };
  L.control.layers(baseLayers,overlays,{collapsed:true}).addTo(map);

  // Default data using new combined format
  const defaultChronoData='Antioch,Turkey~Antioch%0A47-48 AD: Antioch, Syria%0A2025 AD: Antakya, Turkey%0A%0AAntioch served as the primary mission base for Paul\'s ministry to the Gentiles and was where believers were first called Christians|Philippi,Greece~Philippi%0A49-50 AD: Philippi, Macedonia%0A2025 AD: Filippoi, Greece%0A%0APhilippi was the first European city where Paul established a Christian congregation during his second missionary journey|Ephesus,Turkey~Ephesus%0A52-54 AD: Ephesus, Asia Minor%0A2025 AD: SelÃ§uk, Turkey%0A%0APaul ministered in Ephesus for approximately three years during his third missionary journey|Rome,Italy~Rome%0A62 AD: Rome, Capitol of the Roman Empire%0A2025 AD: Rome, Italy%0A%0APaul was held under house arrest in Rome from approximately AD 60 to 62';
  const defaultRefData='Jerusalem,Israel~Jerusalem%0A33 AD: Jerusalem, Judea%0A2025 AD: Jerusalem, Israel%0A%0AThe Church\'s birthplace and site of Pentecost';
  
  // Parse function for new combined format (Location~Label pairs)
  function parseLocationsAndLabels(paramStr){
    const results={locations:[],labels:[]};
    if(!paramStr)return results;
    const entries=paramStr.split('|').filter(Boolean);
    for(const entry of entries){
      const parts=entry.split('~');
      const location=parts[0]?.trim()||'';
      let label=parts[1]?.trim()||'';
      // If label is missing, empty, or explicitly "TBD", use the TBD placeholder
      if(!label||label===''||label==='TBD'){
        label=`TBD%0ATBD: Location information not provided%0A2025 AD: Unknown%0A%0APlease provide complete location details.`;
      }
      results.locations.push(location);
      results.labels.push(label);
    }
    return results;
  }
  
  // Parse URL parameters (chronoLocationsAndLabels and referenceLocationsAndLabels)
  const chronoParam=qs('chronoLocationsAndLabels');
  const refParam=qs('referenceLocationsAndLabels');
  
  // Parse chronological locations - only use defaults when NO URL params at all
  const chronoData=parseLocationsAndLabels(hasAnyParams?chronoParam:defaultChronoData);
  const chronoPoints=chronoData.locations;
  const chronoLabels=chronoData.labels;
  
  // Parse reference locations - only use defaults when NO URL params at all
  const refData=parseLocationsAndLabels(hasAnyParams?refParam:defaultRefData);
  const refPoints=refData.locations;
  const refLabels=refData.labels;

  const allMarkers=[];
  const chronoCoords=[];
  const chronoNames=[];
  
  const totalLocations=chronoPoints.length+refPoints.length;
  let processedCount=0;
  
  // Process chronological locations (blue markers)
  updateLoading('Loading locations...',`Processing chronological locations (0/${chronoPoints.length})`);
  for(let i=0;i<chronoPoints.length;i++){
    const q=chronoPoints[i].trim();
    if(!q)continue;
    
    updateLoading('Loading locations...',`Geocoding: ${q} (${processedCount+1}/${totalLocations})`);
    
    let coord=null;
    const m=q.match(/^(.*)@(-?\d+(?:\.\d+)?),(-?\d+(?:\.\d+)?)$/);
    if(m){coord={lat:parseFloat(m[2]),lon:parseFloat(m[3])};}
    else{coord=await geocode(q);}
    if(!coord)continue;
    chronoCoords.push({lat:coord.lat,lon:coord.lon});
    const labelEncoded=chronoLabels[i]||q;
    const label=labelEncoded.replace(/%0A/gi,'\n');
    const lines=label.split('\n');
    const locationName=lines[0]||q;
    chronoNames.push(locationName);
    const html=lines.map(l=>'<span class="popup-line">'+l+'</span>').join('');
    
    const mk=L.marker([coord.lat,coord.lon],{icon:blueIcon})
      .addTo(map)
      .bindTooltip(locationName,{permanent:true,direction:'top',className:'marker-label'})
      .on('click',()=>openDrawer(html));
    
    allMarkers.push(mk);
    processedCount++;
  }
  
  // Process reference locations (red markers)
  updateLoading('Loading locations...',`Processing reference locations (${processedCount}/${totalLocations})`);
  for(let i=0;i<refPoints.length;i++){
    const q=refPoints[i].trim();
    if(!q)continue;
    
    updateLoading('Loading locations...',`Geocoding: ${q} (${processedCount+1}/${totalLocations})`);
    
    let coord=null;
    const m=q.match(/^(.*)@(-?\d+(?:\.\d+)?),(-?\d+(?:\.\d+)?)$/);
    if(m){coord={lat:parseFloat(m[2]),lon:parseFloat(m[3])};}
    else{coord=await geocode(q);}
    if(!coord)continue;
    const labelEncoded=refLabels[i]||q;
    const label=labelEncoded.replace(/%0A/gi,'\n');
    const lines=label.split('\n');
    const locationName=lines[0]||q;
    const html=lines.map(l=>'<span class="popup-line">'+l+'</span>').join('');
    
    const mk=L.marker([coord.lat,coord.lon],{icon:redIcon})
      .addTo(map)
      .bindTooltip(locationName,{permanent:true,direction:'top',className:'marker-label-reference'})
      .on('click',()=>openDrawer(html));
    
    allMarkers.push(mk);
    processedCount++;
  }
  
  // Purple color palette for different segments (accessible and high contrast)
  const purpleColors=['#9333ea','#7c3aed','#6d28d9','#5b21b6','#4c1d95'];
  
  // Helper function to calculate point along a path at given distance
  function getPointAtDistance(latlngs,targetDist){
    let accumulated=0;
    for(let i=0;i<latlngs.length-1;i++){
      const p1=latlngs[i];
      const p2=latlngs[i+1];
      const segDist=map.distance(p1,p2);
      if(accumulated+segDist>=targetDist){
        const ratio=(targetDist-accumulated)/segDist;
        const lat=p1[0]+(p2[0]-p1[0])*ratio;
        const lng=p1[1]+(p2[1]-p1[1])*ratio;
        const bearing=Math.atan2(p2[1]-p1[1],p2[0]-p1[0])*180/Math.PI;
        return{lat,lng,bearing};
      }
      accumulated+=segDist;
    }
    return null;
  }
  
  // Draw travel paths between consecutive chronological locations with different colors
  updateLoading('Calculating travel routes...',`Preparing ${chronoCoords.length-1} route segments`);
  let totalDistance=0;
  const legDistances=[];
  const legColors=[];
  for(let i=0;i<chronoCoords.length-1;i++){
    updateLoading('Calculating travel routes...',`Route ${i+1} of ${chronoCoords.length-1}: ${chronoNames[i]} â†’ ${chronoNames[i+1]}`);
    const route=await getWalkingRoute(chronoCoords[i],chronoCoords[i+1]);
    const segmentColor=purpleColors[i%purpleColors.length];
    legColors.push(segmentColor);
    if(route&&route.geometry){
      const latlngs=route.geometry.coordinates.map(c=>[c[1],c[0]]);
      
      // Draw main path with white stroke for contrast (thinner lines)
      L.polyline(latlngs,{color:'#ffffff',weight:5,opacity:0.9}).addTo(travelLineAndTime);
      L.polyline(latlngs,{color:segmentColor,weight:3,opacity:0.95}).addTo(travelLineAndTime);
      
      // Calculate total path length
      let pathLength=0;
      for(let j=0;j<latlngs.length-1;j++){
        pathLength+=map.distance(latlngs[j],latlngs[j+1]);
      }
      
      // Add numbered arrow markers at regular intervals (25% fewer markers)
      const segmentNumber=i+1;
      const arrowInterval=Math.min(150000,pathLength/4);
      const numArrows=Math.max(2,Math.floor((pathLength/arrowInterval)*0.75));
      
      for(let a=1;a<=numArrows;a++){
        const distAlongPath=(pathLength/(numArrows+1))*a;
        const point=getPointAtDistance(latlngs,distAlongPath);
        if(point){
          const arrowHtml='<div style="width:18px;height:18px;background:#ffffff;border-radius:50%;display:flex;align-items:center;justify-content:center;font-weight:700;font-size:10px;color:#000;box-shadow:0 2px 6px rgba(0,0,0,0.3),0 0 0 2px '+segmentColor+'">'+segmentNumber+'</div>';
          const arrow=L.marker([point.lat,point.lng],{
            icon:L.divIcon({
              className:'arrow-marker',
              html:arrowHtml,
              iconSize:[18,18],
              iconAnchor:[9,9]
            }),
            interactive:false
          }).addTo(travelLineAndTime);
        }
      }
      
      totalDistance+=route.distance;
      legDistances.push(route.distance);
    }else{
      legDistances.push(0);
    }
  }
  
  if(allMarkers.length){
    const g=new L.featureGroup(allMarkers);
    map.fitBounds(g.getBounds().pad(0.18));
    
    // Create travel time display with transport mode support
    if(totalDistance>0){
      // Transport speeds in km/h (from itiner-e research)
      const transportSpeeds={walking:4,pack:4.5,horse:6,oxcart:2};
      const SAILING_SPEED_KMH=7.4; // 4 knots in km/h
      let currentTransport='walking';
      let currentRouteMode='land'; // 'land' or 'water'
      
      // Mediterranean bounding box for water crossing detection
      const WATER_BOUNDS={minLat:30,maxLat:46,minLon:-6,maxLon:36};
      
      // Calculate straight-line distance between two points (accepts {lat,lon} objects)
      function haversineDistance(start,end){
        const R=6371e3;
        const lat1=start.lat*Math.PI/180,lat2=end.lat*Math.PI/180;
        const dLat=(end.lat-start.lat)*Math.PI/180;
        const dLon=(end.lon-start.lon)*Math.PI/180;
        const a=Math.sin(dLat/2)**2+Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLon/2)**2;
        const c=2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a));
        return R*c;
      }
      
      // Check if a path segment likely crosses water (Mediterranean)
      // OSRM includes modern ferries, so a LOW ratio (route close to straight-line) indicates water crossing
      // True land-only routes going around water would have HIGH ratios (1.5-3x straight-line)
      function isWaterCrossing(start,end,routeDist){
        const straightDist=haversineDistance(start,end);
        
        // Check if midpoint is within Mediterranean basin
        const midLat=(start.lat+end.lat)/2;
        const midLon=(start.lon+end.lon)/2;
        if(midLat<WATER_BOUNDS.minLat||midLat>WATER_BOUNDS.maxLat)return false;
        if(midLon<WATER_BOUNDS.minLon||midLon>WATER_BOUNDS.maxLon)return false;
        
        // Must be at least 100km to consider water crossing (ferries are typically for longer distances)
        if(straightDist<100000)return false;
        
        // Key heuristic: OSRM uses ferries, so a LOW ratio indicates ferry/water usage
        // - Ratio < 1.35: OSRM took a near-direct path (likely using ferries)
        // - Ratio > 1.5: OSRM routed around (true land path)
        // Normal overland routes are typically 1.4-1.6x straight-line due to road curvature
        const ratio=routeDist>0?(routeDist/straightDist):1.0;
        return ratio<1.35;
      }
      
      // Analyze each leg for water crossings
      const legWaterInfo=[];
      for(let i=0;i<chronoCoords.length-1;i++){
        const start=chronoCoords[i];
        const end=chronoCoords[i+1];
        const routeDist=legDistances[i]||0;
        const straightDist=haversineDistance(start,end);
        const isWater=isWaterCrossing(start,end,routeDist);
        
        legWaterInfo.push({isWater,straightDist,routeDist:routeDist||straightDist});
      }
      
      // Calculate travel time based on distance and transport mode
      const formatTime=(distanceMeters,speedKmH)=>{
        const distKm=distanceMeters/1000;
        const hoursPerDay=8; // Assume 8 hours of travel per day
        const totalHours=distKm/speedKmH;
        const totalDays=Math.ceil(totalHours/hoursPerDay);
        const weeks=Math.floor(totalDays/7);
        const days=totalDays%7;
        let timeStr='';
        if(weeks>0)timeStr+=`${weeks} week${weeks>1?'s':''} `;
        if(days>0||weeks===0)timeStr+=`${days} day${days!==1?'s':''}`;
        return {timeStr:timeStr.trim(),distKm:distKm.toFixed(0),totalDays,totalHours:Math.round(totalHours)};
      };
      
      // Create travel time display element (hidden by default)
      const travelTimeDiv=document.createElement('div');
      travelTimeDiv.className='distance-info';
      travelTimeDiv.style.display='none';
      document.body.appendChild(travelTimeDiv);
      
      // Update travel time display based on current transport mode and route mode
      function updateTravelTimeDisplay(){
        const landSpeed=transportSpeeds[currentTransport];
        
        // Calculate totals based on route mode
        let totalLandDist=0,totalWaterDist=0,totalLandHours=0,totalWaterHours=0;
        const legDetails=[];
        
        for(let i=0;i<legWaterInfo.length;i++){
          const info=legWaterInfo[i];
          const legDist=info.routeDist||info.straightDist;
          
          if(currentRouteMode==='water'&&info.isWater){
            // Use sailing for water crossings
            const waterDist=info.straightDist;
            totalWaterDist+=waterDist;
            totalWaterHours+=waterDist/1000/SAILING_SPEED_KMH;
            legDetails.push({type:'water',dist:waterDist,speed:SAILING_SPEED_KMH,name:`${chronoNames[i]} â†’ ${chronoNames[i+1]}`});
          }else{
            // Land travel
            totalLandDist+=legDist;
            totalLandHours+=legDist/1000/landSpeed;
            legDetails.push({type:'land',dist:legDist,speed:landSpeed,name:`${chronoNames[i]} â†’ ${chronoNames[i+1]}`});
          }
        }
        
        const hoursPerDay=8;
        const totalHours=totalLandHours+totalWaterHours;
        const totalDays=Math.ceil(totalHours/hoursPerDay);
        const totalDistKm=((totalLandDist+totalWaterDist)/1000).toFixed(0);
        const weeks=Math.floor(totalDays/7);
        const days=totalDays%7;
        let totalTimeStr='';
        if(weeks>0)totalTimeStr+=`${weeks} week${weeks>1?'s':''} `;
        if(days>0||weeks===0)totalTimeStr+=`${days} day${days!==1?'s':''}`;
        
        // Build legs display with type indicators
        let legsHtml='';
        for(let i=0;i<legDetails.length;i++){
          const leg=legDetails[i];
          const distKm=(leg.dist/1000).toFixed(0);
          const legHours=leg.dist/1000/leg.speed;
          const legDays=Math.ceil(legHours/hoursPerDay);
          const lWeeks=Math.floor(legDays/7);
          const lDays=legDays%7;
          let legTimeStr='';
          if(lWeeks>0)legTimeStr+=`${lWeeks}w `;
          if(lDays>0||lWeeks===0)legTimeStr+=`${lDays}d`;
          
          const segmentNum=i+1;
          const typeIcon=leg.type==='water'?'<span style="color:#0891b2" title="Sea route">âš“</span>':'';
          const segmentLabel=`<span style="display:inline-block;width:18px;height:18px;background:#ffffff;border-radius:50%;text-align:center;line-height:18px;font-size:10px;font-weight:700;border:2px solid ${legColors[i]||'#6b7280'};margin-right:8px;vertical-align:middle;">${segmentNum}</span>`;
          legsHtml+=`<div>${segmentLabel}${typeIcon}${leg.name}: <span style="color:#6b7280;">${legTimeStr} (${distKm} km)</span></div>`;
        }
        
        const modeLabels={walking:'Walking',pack:'Pack Animal',horse:'Horse Courier',oxcart:'Ox Cart'};
        const modeSpeeds={walking:'4',pack:'4.5',horse:'6',oxcart:'2'};
        
        // Build route mode selector (Land Only / Use Water)
        let routeModeHtml='<div class="route-mode-inline"><div class="route-mode-inline-title">Route Type:</div>';
        routeModeHtml+=`<button class="route-btn ${currentRouteMode==='land'?'active':''}" data-route="land"><span class="icon">ðŸš¶</span>Land Only</button>`;
        routeModeHtml+=`<button class="route-btn ${currentRouteMode==='water'?'active':''}" data-route="water"><span class="icon">â›µ</span>Use Water</button>`;
        routeModeHtml+='</div>';
        
        // Build inline transport mode selector
        let transportHtml='<div class="transport-inline"><div class="transport-inline-title">Land Transport:</div>';
        for(const [mode,label] of Object.entries(modeLabels)){
          const isActive=mode===currentTransport?'active':'';
          transportHtml+=`<button class="transport-btn ${isActive}" data-mode="${mode}">${label} <span class="speed">(${modeSpeeds[mode]} km/h)</span></button>`;
        }
        transportHtml+='</div>';
        
        // Water breakdown info
        let waterBreakdownHtml='';
        if(currentRouteMode==='water'&&totalWaterDist>0){
          const waterKm=(totalWaterDist/1000).toFixed(0);
          const landKm=(totalLandDist/1000).toFixed(0);
          const waterDays=Math.ceil(totalWaterHours/hoursPerDay);
          const landDays=Math.ceil(totalLandHours/hoursPerDay);
          waterBreakdownHtml=`<div class="water-breakdown">âš“ Sea: ${waterKm} km (${waterDays}d @ 4 knots) | ðŸš¶ Land: ${landKm} km (${landDays}d)</div>`;
        }
        
        const headerLabel=currentRouteMode==='water'?`${modeLabels[currentTransport]} + Sailing`:`${modeLabels[currentTransport]}`;
        
        travelTimeDiv.innerHTML=`
          <div class="distance-info-header">
            <div><strong>Travel Time (${headerLabel}):</strong> ${totalTimeStr.trim()} <span style="font-size:12px;color:#6b7280">(${totalDistKm} km)</span></div>
            <button class="distance-info-toggle" onclick="this.parentElement.nextElementSibling.classList.toggle('expanded');this.textContent=this.textContent==='â–¼'?'â–²':'â–¼'">â–¼</button>
          </div>
          <div class="distance-info-details">${legsHtml}${waterBreakdownHtml}</div>
          ${routeModeHtml}
          ${transportHtml}
        `;
        
        // Attach click handlers to route mode buttons
        travelTimeDiv.querySelectorAll('.route-btn').forEach(btn=>{
          btn.addEventListener('click',function(){
            currentRouteMode=this.dataset.route;
            updateTravelTimeDisplay();
          });
        });
        
        // Attach click handlers to transport buttons
        travelTimeDiv.querySelectorAll('.transport-btn').forEach(btn=>{
          btn.addEventListener('click',function(){
            currentTransport=this.dataset.mode;
            updateTravelTimeDisplay();
          });
        });
      }
      
      // Initial display
      updateTravelTimeDisplay();
      
      // Show/hide travel time display based on layer toggle
      map.on('overlayadd',function(e){
        if(e.layer===travelLineAndTime){
          travelTimeDiv.style.display='block';
        }
      });
      map.on('overlayremove',function(e){
        if(e.layer===travelLineAndTime){
          travelTimeDiv.style.display='none';
        }
      });
    }
  }else{map.setView([37.8,20],5);}
  
  // Rendering complete - hide loading overlay
  updateLoading('Map ready!','All locations loaded successfully');
  setTimeout(hideLoading,500);
})();
</script>
</body>
</html>
